{"version":3,"sources":["parallaxative.js"],"names":["ScrollDetector","scrollTarget","options","_this","this","_classCallCheck","defaultOptions","scrollIsVertical","Object","assign","getOwnPropertyNames","forEach","name","updateResizeProperties","window","addEventListener","rect","getBoundingClientRect","documentOffsets","top","constructor","getVerticalScroll","left","getHorizontalScroll","windowSizes","width","innerWidth","height","innerHeight","offset","size","windowSize","scrollPos","zeroPoint","relativeScrollPosition","arguments","length","undefined","Math","min","max","scrollY","pageYOffset","document","documentElement","scrollTop","body","scrollX","pageXOffset","scrollLeft","ScrollTrigger","scrollDetector","_this2","triggerTarget","activeMediaQueryList","matchMedia","activateImmediately","triggerPosition","triggerFunction","el","classList","remove","triggerOnDeactivate","addListener","respond","_this3","listener","requestUpdate","deactivate","ticking","_this4","requestAnimationFrame","test","activated","init","removeEventListener","trigger","matches","activate","ScrollAnimationValueSet","_this5","unit","valueFormat","substitutionString","startValue","endValue","resetValue","scrollPosition","replace","toString","ScrollAnimation","animateTargets","_this6","valueSets","properties","valueSetSeparator","removePropertiesOnReset","startPosition","endPosition","listeners","_this7","animateTarget","add","updateCSS","push","e","cssValues","i","j","animateProperty","style","join","clampedRelativeScrollPosition","getCSSValue","setCSS","_this8","_this9","property","removeProperty","valueSet","reset","ParallaxAnimationValueSet","_this10","scrollPixelsPerParallaxPixel","ParallaxAnimation","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_this12","xDimensions","Size","yDimensions","dimensions","_get","prototype","updateResizeCSS","scrollTranslate","scrollTargetSize","parallaxSize","scrollTargetRect","scrollDistance","abs","valueSetsLength","animateTargetsLength","event","_this13","type"],"mappings":"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","file":"parallaxative.min.js","sourcesContent":["/**\n * Track the relative position of an element as it scrolls by.\n */\nclass ScrollDetector {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {HTMLElement} scrollTarget\n\t *     Element whose position to track\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {bool} scrollIsVertical: Whether to track horizontal or vertical scrolling position.\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(scrollTarget, options) {\n\t\tvar defaultOptions = {\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\tthis.scrollTarget = scrollTarget;\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.updateResizeProperties();\n\n\t\twindow.addEventListener('resize', () => {\n\t\t\tthis.updateResizeProperties();\n\t\t});\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeProperties();\n\t\t});\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.rect = this.scrollTarget.getBoundingClientRect();\n\t\tthis.documentOffsets = {top: this.rect.top + this.constructor.getVerticalScroll(), left: this.rect.left + this.constructor.getHorizontalScroll() }\n\t\tthis.windowSizes = { width: window.innerWidth, height: window.innerHeight };\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos;\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscrollPos = this.constructor.getVerticalScroll();\n\t\t\toffset = this.documentOffsets.top;\n\t\t\tsize = this.rect.height;\n\t\t\twindowSize = this.windowSizes.height;\n\n\t\t} else {\n\t\t\tscrollPos = this.constructor.getHorizontalScroll();\n\t\t\toffset = this.documentOffsets.left;\n\t\t\tsize = this.rect.width;\n\t\t\twindowSize = this.windowSizes.width;\n\t\t}\n\n\t\tvar zeroPoint = offset - windowSize;\n\t\tvar completePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tstatic getVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tstatic getHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}\n\n/**\n * Run a function based on a ScrollDetector\n */\nclass ScrollTrigger {\n\tconstructor(scrollDetector, options = {}, triggerTarget = scrollDetector.scrollTarget) {\n\t\tvar defaultOptions = {\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\ttriggerPosition: 0.15,\n\t\t\ttriggerFunction: function(el) {\n\t\t\t\tel.classList.remove('offscreen');\n\t\t\t},\n\t\t\ttriggerOnDeactivate: true\n\t\t}\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.triggerTarget = triggerTarget;\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\t}\n\n\tinit() {\n\t\tthis.listener = () => {\n\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\tthis.requestUpdate();\n\t\t\t}\n\t\t};\n\n\t\tthis.listener();\n\n\t\twindow.addEventListener('scroll', this.listener);\n\t\twindow.addEventListener('resize', this.listener);\n\t}\n\n\ttrigger() {\n\t\tthis.triggerFunction(this.triggerTarget);\n\t}\n\n\ttest() {\n\t\tif(this.scrollDetector.relativeScrollPosition() > this.triggerPosition) {\n\t\t\tthis.triggerOnDeactivate = true;\n\t\t\tthis.deactivate();\n\t\t}\n\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.test(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\twindow.removeEventListener('scroll', this.listener);\n\t\t\twindow.removeEventListener('resize', this.listener);\n\n\t\t\tif(this.triggerOnDeactivate) {\n\t\t\t\tthis.trigger();\n\t\t\t}\n\t\t}\n\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n\n/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nclass ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translate3d(0px, _, 1px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\tgetCSSValue(scrollPosition) {\n\t\treturn this.valueFormat.replace(this.substitutionString, ((this.endValue - this.startValue) * scrollPosition + this.startValue).toString() + this.unit)\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nclass ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSetSeparator: ' ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\tstartPosition: 0, // FIXME: Not implemented\n\t\t\tendPosition: 1 // FIXME: Not implemented\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.valueSets = valueSets;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tthis.ticking = false;\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tcssValues.push( this.valueSets[i].getCSSValue(scrollPosition) );\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property)\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t\twindow.removeEventListener('resize', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n/**\n * Default option container for ParallaxAnimation CSS values.\n */\nclass ParallaxAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translate3d(0px, _, 1px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel === 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must not be zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tvar xDimensions = { size: 'width', Size: 'Width', offset: 'left' };\n\t\tvar yDimensions = { size: 'height', Size: 'Height', offset: 'top' }\n\t\tthis.dimensions =  this.scrollDetector.scrollIsVertical ? yDimensions : xDimensions;\n\n\t\tthis.updateResizeProperties();\n\n\t\tsuper.init();\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeCSS();\n\t\t\tthis.updateCSS();\n\t\t});\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallax-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallax-container')\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar cssValues = [];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tvar scrollTranslate;\n\n\t\t\tif(this.valueSets[i].scrollPixelsPerParallaxPixel < 0) {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * (1 - scrollPosition));\n\t\t\t} else {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * scrollPosition);\n\t\t\t}\n\n\t\t\tcssValues.push(\n\t\t\t\tthis.valueSets[i].valueFormat.replace(this.valueSets[i].substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tthis.scrollTargetSize = this.scrollTargetRect[this.dimensions.size];\n\t\tthis.scrollDistance = this.scrollTargetSize + window['inner' + this.dimensions.Size];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.valueSets[i].parallaxSize = Math.abs(this.scrollDistance / this.valueSets[i].scrollPixelsPerParallaxPixel) + this.scrollTargetSize;\n\t\t}\n\t}\n\n\tupdateResizeCSS() {\n\t\tthis.updateResizeProperties();\n\n\t\tvar valueSetsLength = this.valueSets.length;\n\t\tvar animateTargetsLength = this.animateTargets.length;\n\n\t\tfor (var i = 0; i < valueSetsLength; i++) {\n\t\t\tfor (var j = 0; j < animateTargetsLength; j++) {\n\t\t\t\tthis.animateTargets[j].style[this.dimensions.size] = this.valueSets[i].parallaxSize.toString() + 'px';\n\t\t\t}\n\t\t}\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n}\n\nexport { ScrollDetector, ScrollTrigger, ScrollAnimation, ScrollAnimationValueSet, ParallaxAnimation, ParallaxAnimationValueSet };"]}