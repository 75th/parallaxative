{"version":3,"sources":["parallaxative.js"],"names":["ParallaxativeAnimationValueSet","options","_this","this","_classCallCheck","defaultOptions","valueFormat","substitutionString","scrollPixelsPerParallaxPixel","resetValue","Object","assign","getOwnPropertyNames","forEach","name","ParallaxativeAnimation","animateTargets","scrollDetector","valueSets","arguments","length","undefined","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_get","prototype","updateResizeCSS","animateTarget","classList","add","scrollTarget","stats","xDimensions","size","Size","offset","yDimensions","dimensions","scroll","cross","scrollPosition","clampedRelativeScrollPosition","scrollIsVertical","scrollTargetRect","getBoundingClientRect","scrollTargetScrollSize","scrollDistance","window","s","getStats","cssValues","valueSet","parallaxSize","Math","ceil","scrollTranslate","round","push","replace","toString","setCSS","ticking","_this3","style","event","_this4","requestAnimationFrame","updateCSS","type","ScrollAnimation"],"mappings":"unCAGMA,+BAcL,QAAAA,GAAYC,GAAS,GAAAC,GAAAC,IAAAC,iBAAAD,KAAAH,EACpB,IAAIK,IACHC,YAAa,gBACbC,mBAAoB,IACpBC,6BAA8B,GAC9BC,WAAY,EASb,IANAR,EAAUS,OAAOC,UAAWN,EAAgBJ,GAE5CS,OAAOE,oBAAoBX,GAASY,QAAQ,SAAAC,GAC3CZ,EAAKY,GAAQb,EAAQa,KAGnBX,KAAKK,8BAAgC,EACvC,KAAM,2DAQHO,mCAuBL,QAAAA,GAAYC,EAAgBC,EAAgBhB,GAA6D,GAApDiB,GAAoDC,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,IAAtC,GAAInB,gCAAkC,OAAAI,iBAAAD,KAAAY,GAAAO,2BAAAnB,MAAAY,EAAAQ,WAAAb,OAAAc,eAAAT,IAAAU,KAAAtB,KAClGa,EAAgBC,EAAgBhB,EAASiB,yEAS/CQ,KAAAX,EAAAY,UAAAJ,WAAAb,OAAAc,eAAAT,EAAAY,WAAA,OAAAxB,MAAAsB,KAAAtB,MAEAA,KAAKyB,kBAELzB,KAAKa,eAAeH,QAAQ,SAAAgB,GAC3BA,EAAcC,UAAUC,IAAI,4BAG7B5B,KAAKc,eAAee,aAAaF,UAAUC,IAAI,gEAI/C,GAAIE,MACAC,GAAgBC,KAAM,QAASC,KAAM,QAASC,OAAQ,QACtDC,GAAgBH,KAAM,SAAUC,KAAM,SAAUC,OAAQ,MAa5D,OAXAJ,GAAMM,YAAgBC,UAAYC,UAElCR,EAAMS,eAAiBvC,KAAKc,eAAe0B,gCAE3CV,EAAMM,WAAWC,OAASrC,KAAKc,eAAe2B,iBAAmBN,EAAcJ,EAC/ED,EAAMM,WAAWE,MAAQR,EAAMM,WAAWC,SAAWN,EAAcI,EAAcJ,EAEjFD,EAAMY,iBAAmB1C,KAAKc,eAAee,aAAac,wBAC1Db,EAAMc,uBAAyBd,EAAMY,iBAAiBZ,EAAMM,WAAWC,OAAOL,MAC9EF,EAAMe,eAAiBf,EAAMc,uBAAyBE,OAAO,QAAUhB,EAAMM,WAAWC,OAAOJ,MAExFH,wCASP,GAAIiB,GAAI/C,KAAKgD,WACTC,IAEJjD,MAAKe,UAAUL,QAAQ,SAAAwC,GACtB,GAAIC,GAAeC,KAAKC,KAAKN,EAAEF,eAAkBE,EAAEF,eAAiBK,EAAS7C,6BAAgC0C,EAAEH,wBAC3GU,EAAkBF,KAAKG,QAASR,EAAEH,uBAAyBO,GAAgBJ,EAAER,eAEjFU,GAAUO,KACTN,EAAS/C,YAAYsD,QAAQP,EAAS9C,mBAAoBkD,EAAgBI,WAAa,SAMzF1D,KAAK2D,OAAOV,GACZjD,KAAK4D,SAAU,8CAGE,GAAAC,GAAA7D,KACb+C,EAAI/C,KAAKgD,UAEbhD,MAAKe,UAAUL,QAAQ,SAAAwC,GACtB,GAAIC,GAAeC,KAAKG,MAAMR,EAAEF,eAAkBE,EAAEF,eAAiBK,EAAS7C,6BAAgC0C,EAAEH,uBAEhHiB,GAAKhD,eAAeH,QAAQ,SAAAgB,GAC3BA,EAAcoC,MAAMf,EAAEX,WAAWC,OAAOL,MAAQmB,EAAaO,WAAa,iDAK/DK,GAAO,GAAAC,GAAAhE,IAChBA,MAAK4D,SACRK,sBAAsB,WACrBD,EAAKE,YAEa,WAAfH,EAAMI,MACRH,EAAKvC,oBAKRzB,KAAK4D,SAAU,SA9GoBQ","file":"parallaxative.min.js","sourcesContent":["/**\n * Default option container for ParallaxativeAnimation CSS values.\n */\nclass ParallaxativeAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translateY(_)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel <= 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must be greater than zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxativeAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxativeAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tsuper.init();\n\n\t\tthis.updateResizeCSS();\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallaxative-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallaxative-container')\n\t}\n\n\tgetStats() {\n\t\tvar stats = {};\n\t\tvar xDimensions = { size: 'width', Size: 'Width', offset: 'left' };\n\t\tvar yDimensions = { size: 'height', Size: 'Height', offset: 'top' }\n\n\t\tstats.dimensions =  { scroll: {}, cross: {} }\n\n\t\tstats.scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tstats.dimensions.scroll = this.scrollDetector.scrollIsVertical ? yDimensions : xDimensions;\n\t\tstats.dimensions.cross = stats.dimensions.scroll === xDimensions ? yDimensions : xDimensions;\n\n\t\tstats.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tstats.scrollTargetScrollSize = stats.scrollTargetRect[stats.dimensions.scroll.size];\n\t\tstats.scrollDistance = stats.scrollTargetScrollSize + window['inner' + stats.dimensions.scroll.Size];\n\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar s = this.getStats();\n\t\tvar cssValues = [];\n\n\t\tthis.valueSets.forEach(valueSet => {\n\t\t\tvar parallaxSize = Math.ceil(s.scrollDistance - (s.scrollDistance / valueSet.scrollPixelsPerParallaxPixel) + s.scrollTargetScrollSize);\n\t\t\tvar scrollTranslate = Math.round(-((s.scrollTargetScrollSize - parallaxSize) * s.scrollPosition));\n\n\t\t\tcssValues.push(\n\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\n\n\t\t});\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeCSS() {\n\t\tvar s = this.getStats();\n\n\t\tthis.valueSets.forEach(valueSet => {\n\t\t\tvar parallaxSize = Math.round(s.scrollDistance - (s.scrollDistance / valueSet.scrollPixelsPerParallaxPixel) + s.scrollTargetScrollSize);\n\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tanimateTarget.style[s.dimensions.scroll.size] = parallaxSize.toString() + 'px';\n\t\t\t});\n\t\t})\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n}"]}