{"version":3,"sources":["parallaxative.js"],"names":["ScrollDetector","scrollTarget","options","_this","this","_classCallCheck","defaultOptions","scrollIsVertical","Object","assign","getOwnPropertyNames","forEach","name","offset","size","windowSize","scrollPos","rect","getBoundingClientRect","getVerticalScroll","top","height","window","innerHeight","getHorizontalScroll","left","width","innerWidth","zeroPoint","relativeScrollPosition","arguments","length","undefined","Math","min","max","scrollY","pageYOffset","document","documentElement","scrollTop","body","scrollX","pageXOffset","scrollLeft","ScrollAnimationValueSet","_this2","unit","valueFormat","substitutionString","startValue","endValue","resetValue","scrollPosition","replace","toString","ScrollAnimation","animateTargets","scrollDetector","_this3","valueSets","properties","valueSetSeparator","removePropertiesOnReset","activeMediaQueryList","matchMedia","activateImmediately","listeners","ticking","activated","respond","addListener","_this4","animateTarget","classList","add","updateCSS","push","e","requestUpdate","addEventListener","cssValues","i","j","animateProperty","style","join","clampedRelativeScrollPosition","getCSSValue","setCSS","_this5","requestAnimationFrame","_this6","property","removeProperty","valueSet","init","listener","removeEventListener","reset","matches","activate","deactivate","ParallaxAnimationValueSet","_this7","scrollPixelsPerParallaxPixel","ParallaxAnimation","_possibleConstructorReturn","__proto__","getPrototypeOf","call","xDimensions","Size","yDimensions","dimensions","updateResizeProperties","_get","prototype","updateResizeCSS","scrollTranslate","scrollTargetSize","parallaxSize","scrollTargetRect","scrollDistance","valueSetsLength","animateTargetsLength","event","_this9","type"],"mappings":"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","file":"parallaxative.min.js","sourcesContent":["/**\n * Track the relative position of an element as it scrolls by.\n */\nexport class ScrollDetector {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {HTMLElement} scrollTarget\n\t *     Element whose position to track\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {bool} scrollIsVertical: Whether to track horizontal or vertical scrolling position.\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(scrollTarget, options) {\n\t\tvar defaultOptions = {\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\tthis.scrollTarget = scrollTarget;\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos;\n\n\t\tvar rect = this.scrollTarget.getBoundingClientRect();\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscrollPos = this.getVerticalScroll();\n\t\t\toffset = rect.top + scrollPos;\n\t\t\tsize = rect.height;\n\t\t\twindowSize = window.innerHeight;\n\n\t\t} else {\n\t\t\tscrollPos = this.getHorizontalScroll();\n\t\t\toffset = rect.left + scrollPos;\n\t\t\tsize = rect.width;\n\t\t\twindowSize = window.innerWidth;\n\t\t}\n\n\t\tvar zeroPoint = offset - windowSize;\n\t\tvar completePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tgetVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tgetHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}\n\n\n/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nexport class ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translate3d(0, _, 0)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\tgetCSSValue(scrollPosition) {\n\t\treturn this.valueFormat.replace(this.substitutionString, ((this.endValue - this.startValue) * scrollPosition + this.startValue).toString() + this.unit)\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nexport class ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSetSeparator: ', ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.valueSets = valueSets;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 || relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tcssValues.push( this.valueSets[i].getCSSValue(scrollPosition) );\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property)\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t\twindow.removeEventListener('resize', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n/**\n * Default option container for ParallaxAnimation CSS values.\n */\nexport class ParallaxAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translateY(_)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel <= 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must be greater than zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nexport class ParallaxAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tvar xDimensions = { size: 'width', Size: 'Width', offset: 'left' };\n\t\tvar yDimensions = { size: 'height', Size: 'Height', offset: 'top' }\n\t\tthis.dimensions =  this.scrollDetector.scrollIsVertical ? yDimensions : xDimensions;\n\n\t\tthis.updateResizeProperties();\n\n\t\tsuper.init();\n\n\t\tthis.updateResizeCSS();\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallax-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallax-container')\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\t\tvar cssValues = [];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tvar scrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * scrollPosition);\n\n\t\t\tcssValues.push(\n\t\t\t\tthis.valueSets[i].valueFormat.replace(this.valueSets[i].substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tthis.scrollTargetSize = this.scrollTargetRect[this.dimensions.size];\n\t\tthis.scrollDistance = this.scrollTargetSize + window['inner' + this.dimensions.Size];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.valueSets[i].parallaxSize = (this.scrollDistance - (this.scrollDistance / this.valueSets[i].scrollPixelsPerParallaxPixel) + this.scrollTargetSize);\n\t\t}\n\t}\n\n\tupdateResizeCSS() {\n\t\tthis.updateResizeProperties();\n\n\t\tvar valueSetsLength = this.valueSets.length;\n\t\tvar animateTargetsLength = this.animateTargets.length;\n\n\t\tfor (var i = 0; i < valueSetsLength; i++) {\n\t\t\tfor (var j = 0; j < animateTargetsLength; j++) {\n\t\t\t\tthis.animateTargets[j].style[this.dimensions.size] = this.valueSets[i].parallaxSize.toString() + 'px';\n\t\t\t}\n\t\t}\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n}"]}