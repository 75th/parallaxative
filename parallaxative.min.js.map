{"version":3,"sources":["parallaxative.js"],"names":["ParallaxativeAnimationValueSet","options","_this","this","_classCallCheck","defaultOptions","valueFormat","substitutionString","scrollPixelsPerParallaxPixel","resetValue","Object","assign","getOwnPropertyNames","forEach","name","ParallaxativeAnimation","animateTargets","scrollDetector","valueSets","arguments","length","undefined","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_get","prototype","animateTarget","classList","add","scrollTarget","_this3","cssValues","scrollPosition","clampedRelativeScrollPosition","dimension","scrollIsVertical","capitalizedDimension","slice","toUpperCase","scrollTargetSize","getBoundingClientRect","scrollDistance","window","valueSet","parallaxSize","pos","push","replace","toString","style","ticking","ScrollAnimation"],"mappings":"unCAGMA,+BAcL,QAAAA,GAAYC,GAAS,GAAAC,GAAAC,IAAAC,iBAAAD,KAAAH,EACpB,IAAIK,IACHC,YAAa,gBACbC,mBAAoB,IACpBC,6BAA8B,GAC9BC,WAAY,EASb,IANAR,EAAUS,OAAOC,UAAWN,EAAgBJ,GAE5CS,OAAOE,oBAAoBX,GAASY,QAAQ,SAAAC,GAC3CZ,EAAKY,GAAQb,EAAQa,KAGnBX,KAAKK,8BAAgC,EACvC,KAAM,2DAQHO,mCAuBL,QAAAA,GAAYC,EAAgBC,EAAgBhB,GAA6D,GAApDiB,GAAoDC,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,IAAtC,GAAInB,gCAAkC,OAAAI,iBAAAD,KAAAY,GAAAO,2BAAAnB,MAAAY,EAAAQ,WAAAb,OAAAc,eAAAT,IAAAU,KAAAtB,KAClGa,EAAgBC,EAAgBhB,EAASiB,yEAS/CQ,KAAAX,EAAAY,UAAAJ,WAAAb,OAAAc,eAAAT,EAAAY,WAAA,OAAAxB,MAAAsB,KAAAtB,MAEAA,KAAKa,eAAeH,QAAQ,SAAAe,GAC3BA,EAAcC,UAAUC,IAAI,4BAG7B3B,KAAKc,eAAec,aAAaF,UAAUC,IAAI,iEAQpC,GAAAE,GAAA7B,KACP8B,KACAC,EAAiB/B,KAAKc,eAAekB,gCAErCC,EAAYjC,KAAKc,eAAeoB,iBAAmB,SAAW,QAC9DC,EAAuBF,EAAUG,MAAM,EAAE,GAAGC,cAAgBJ,EAAUG,MAAM,GAC5EE,EAAmBtC,KAAKc,eAAec,aAAaW,wBAAwBN,GAC5EO,EAAiBF,EAAmBG,OAAO,QAAUN,EAEzDnC,MAAKe,UAAUL,QAAQ,SAAAgC,GAGtB,GAAIC,GAAeH,EAAkBA,EAAiBE,EAASrC,6BAAgCiC,EAC3FM,GAAQD,EAAeL,GAAoBP,CAE/CD,GAAUe,KACTH,EAASvC,YAAY2C,QAAQJ,EAAStC,mBAAoBwC,EAAIG,WAAa,OAG5ElB,EAAKhB,eAAeH,QAAQ,SAAAe,GAC3BA,EAAcuB,MAAMf,GAAaU,EAAaI,WAAa,SAI7DxB,KAAAX,EAAAY,UAAAJ,WAAAb,OAAAc,eAAAT,EAAAY,WAAA,SAAAxB,MAAAsB,KAAAtB,KAAa8B,GACb9B,KAAKiD,SAAU,SAxEoBC","file":"parallaxative.min.js","sourcesContent":["/**\n * Default option container for ParallaxativeAnimation CSS values.\n */\nclass ParallaxativeAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translateY(_)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel <= 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must be greater than zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxativeAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxativeAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tsuper.init();\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallaxative-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallaxative-container')\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar cssValues = [];\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar dimension = this.scrollDetector.scrollIsVertical ? 'height' : 'width';\n\t\tvar capitalizedDimension = dimension.slice(0,1).toUpperCase() + dimension.slice(1);\n\t\tvar scrollTargetSize = this.scrollDetector.scrollTarget.getBoundingClientRect()[dimension];\n\t\tvar scrollDistance = scrollTargetSize + window['inner' + capitalizedDimension];\n\n\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t// FIXME: scrollPixelsPerParallaxPixel is not quite being mathed right here.\n\t\t\t// I need to work in the ratio between the scrollTarget height and the window height somewhere.\n\t\t\tvar parallaxSize = scrollDistance - (scrollDistance / valueSet.scrollPixelsPerParallaxPixel) + scrollTargetSize;\n\t\t\tvar pos = ((parallaxSize - scrollTargetSize) * scrollPosition);\n\n\t\t\tcssValues.push(\n\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, pos.toString() + 'px')\n\t\t\t);\n\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tanimateTarget.style[dimension] = parallaxSize.toString() + 'px'; // FIXME: Do this once, not every tick!!\n\t\t\t});\n\t\t});\n\n\t\tsuper.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n}"]}