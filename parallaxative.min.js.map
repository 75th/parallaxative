{"version":3,"sources":["parallaxative.js"],"names":["ParallaxativeAnimationValueSet","options","_this","this","_classCallCheck","defaultOptions","valueFormat","substitutionString","scrollPixelsPerParallaxPixel","resetValue","Object","assign","getOwnPropertyNames","forEach","name","ParallaxativeAnimation","animateTargets","scrollDetector","valueSets","arguments","length","undefined","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_get","prototype","animateTarget","classList","add","scrollTarget","_this3","cssValues","scrollPosition","clampedRelativeScrollPosition","scrollTargetRect","getBoundingClientRect","dimension","scrollIsVertical","capitalizedDimension","slice","toUpperCase","scrollDistance","window","valueSet","parallaxDistance","Math","floor","pos","push","replace","toString","targetDimensionSize","ceil","clientHeight","style","ticking","ScrollAnimation"],"mappings":"unCAGMA,+BAcL,QAAAA,GAAYC,GAAS,GAAAC,GAAAC,IAAAC,iBAAAD,KAAAH,EACpB,IAAIK,IACHC,YAAa,gBACbC,mBAAoB,IACpBC,6BAA8B,GAC9BC,WAAY,EASb,IANAR,EAAUS,OAAOC,UAAWN,EAAgBJ,GAE5CS,OAAOE,oBAAoBX,GAASY,QAAQ,SAAAC,GAC3CZ,EAAKY,GAAQb,EAAQa,KAGnBX,KAAKK,8BAAgC,EACvC,KAAM,2DAQHO,mCAuBL,QAAAA,GAAYC,EAAgBC,EAAgBhB,GAA6D,GAApDiB,GAAoDC,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,IAAtC,GAAInB,gCAAkC,OAAAI,iBAAAD,KAAAY,GAAAO,2BAAAnB,MAAAY,EAAAQ,WAAAb,OAAAc,eAAAT,IAAAU,KAAAtB,KAClGa,EAAgBC,EAAgBhB,EAASiB,yEAS/CQ,KAAAX,EAAAY,UAAAJ,WAAAb,OAAAc,eAAAT,EAAAY,WAAA,OAAAxB,MAAAsB,KAAAtB,MAEAA,KAAKa,eAAeH,QAAQ,SAAAe,GAC3BA,EAAcC,UAAUC,IAAI,4BAG7B3B,KAAKc,eAAec,aAAaF,UAAUC,IAAI,iEAQpC,GAAAE,GAAA7B,KACP8B,KACAC,EAAiB/B,KAAKc,eAAekB,gCAErCC,EAAmBjC,KAAKc,eAAec,aAAaM,wBAEpDC,EAAYnC,KAAKc,eAAesB,iBAAmB,SAAW,QAC9DC,EAAuBF,EAAUG,MAAM,EAAE,GAAGC,cAAgBJ,EAAUG,MAAM,GAE5EE,EAAiBP,EAAiBE,GAAaM,OAAO,QAAUJ,EAEpErC,MAAKe,UAAUL,QAAQ,SAAAgC,GAEtB,GAAIC,GAAmBC,KAAKC,MAAML,EAAiBE,EAASrC,8BACxDyC,GAAOH,EAAmBZ,CAE9BD,GAAUiB,KACTL,EAASvC,YAAY6C,QAAQN,EAAStC,mBAAoB0C,EAAIG,WAAa,OAG5EpB,EAAKhB,eAAeH,QAAQ,SAAAe,GAC3B,GAAIyB,GAAsBN,KAAKO,KAAKtB,EAAKf,eAAec,aAAawB,aAAeT,GAAkBM,WAAa,IAEnHxB,GAAc4B,MAAMlB,GAAae,MAInC3B,KAAAX,EAAAY,UAAAJ,WAAAb,OAAAc,eAAAT,EAAAY,WAAA,SAAAxB,MAAAsB,KAAAtB,KAAa8B,GACb9B,KAAKsD,SAAU,SA3EoBC","file":"parallaxative.min.js","sourcesContent":["/**\n * Default option container for ParallaxativeAnimation CSS values.\n */\nclass ParallaxativeAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translateY(_)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel <= 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must be greater than zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxativeAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxativeAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tsuper.init();\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallaxative-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallaxative-container')\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar cssValues = [];\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\n\t\tvar dimension = this.scrollDetector.scrollIsVertical ? 'height' : 'width';\n\t\tvar capitalizedDimension = dimension.slice(0,1).toUpperCase() + dimension.slice(1);\n\n\t\tvar scrollDistance = scrollTargetRect[dimension] + window['inner' + capitalizedDimension];\n\n\t\tthis.valueSets.forEach(valueSet => {\n\n\t\t\tvar parallaxDistance = Math.floor(scrollDistance / valueSet.scrollPixelsPerParallaxPixel);\n\t\t\tvar pos = -parallaxDistance * scrollPosition;\n\n\t\t\tcssValues.push(\n\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, pos.toString() + 'px')\n\t\t\t);\n\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tvar targetDimensionSize = Math.ceil(this.scrollDetector.scrollTarget.clientHeight + parallaxDistance).toString() + 'px';\n\n\t\t\t\tanimateTarget.style[dimension] = targetDimensionSize; // FIXME: Do this once, not every tick!!\n\t\t\t});\n\t\t});\n\n\t\tsuper.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n}"]}