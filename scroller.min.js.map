{"version":3,"sources":["scroller.js"],"names":["ScrollAnimationValueSet","options","_this","this","_classCallCheck","defaultOptions","unit","valueFormat","substitutionString","startValue","endValue","resetValue","Object","assign","getOwnPropertyNames","forEach","name","ScrollAnimation","animateTargets","scrollDetector","_this2","valueSets","arguments","length","undefined","properties","valueSetSeparator","removePropertiesOnReset","activeMediaQueryList","window","matchMedia","activateImmediately","listeners","ticking","activated","respond","addListener","_this3","animateTarget","classList","add","updateCSS","push","e","relativeScrollPosition","requestUpdate","addEventListener","cssValues","i","j","animateProperty","style","join","scrollPosition","clampedRelativeScrollPosition","valueSet","replace","toString","setCSS","_this4","requestAnimationFrame","_this5","property","removeProperty","init","listener","removeEventListener","reset","matches","activate","deactivate","ScrollDetector","scrollTarget","_this6","scrollIsVertical","offset","size","windowSize","scrollPos","scroll","rect","getBoundingClientRect","getVerticalScroll","top","height","innerHeight","pageYOffset","getHorizontalScroll","left","width","innerWidth","pageXOffset","zeroPoint","Math","min","max","scrollY","document","documentElement","scrollTop","body","scrollX","scrollLeft"],"mappings":"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","file":"scroller.min.js","sourcesContent":["/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nclass ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translateY(_)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nclass ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSetSeparator: ', ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.valueSets = valueSets;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 || relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tthis.valueSets.forEach(valueSet => {\n\t\t\tcssValues.push(\n\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, ((valueSet.endValue - valueSet.startValue) * scrollPosition + valueSet.startValue).toString() + valueSet.unit)\n\t\t\t);\n\t\t});\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property)\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n\n/**\n * Track the relative position of an element as it scrolls by.\n */\nclass ScrollDetector {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {HTMLElement} scrollTarget\n\t *     Element whose position to track\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {bool} scrollIsVertical: Whether to track horizontal or vertical scrolling position.\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(scrollTarget, options) {\n\t\tvar defaultOptions = {\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\tthis.scrollTarget = scrollTarget;\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos, scroll;\n\n\t\tvar rect = this.scrollTarget.getBoundingClientRect();\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscroll = this.getVerticalScroll();\n\t\t\toffset = rect.top + scroll;\n\t\t\tsize = rect.height;\n\t\t\twindowSize = window.innerHeight;\n\t\t\tscrollPos = window.pageYOffset;\n\t\t} else {\n\t\t\tscroll = this.getHorizontalScroll();\n\t\t\toffset = rect.left + scroll;\n\t\t\tsize = rect.width;\n\t\t\twindowSize = window.innerWidth;\n\t\t\tscrollPos = window.pageXOffset;\n\t\t}\n\n\t\tvar zeroPoint = offset - windowSize;\n\t\tvar completePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tgetVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tgetHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}"]}