{"version":3,"sources":["../src/parallaxative.js"],"names":["validateOptions","options","properties","_typeof","valueSets","ScrollAnimationValueSet","ParallaxAnimationValueSet","normalizeMediaQueryList","mql","MediaQueryList","window","matchMedia","ParallaxativeException","normalizeDOMElement","el","HTMLElement","document","querySelector","normalizeScrollDetector","scrollDetector","defaultScrollTarget","ScrollDetector","scrollTarget","scrollIsVertical","console","warn","throwingFunction","type","arguments","length","undefined","data","log","error","_classCallCheck","this","ScrollTrigger","ParallaxAnimation","animateTarget","constructor","_this","defaultOptions","Object","getOwnPropertyNames","forEach","name","updateResizeProperties","addEventListener","rect","getBoundingClientRect","documentOffsets","top","getVerticalScroll","left","getHorizontalScroll","windowSizes","width","innerWidth","height","innerHeight","assign","offset","size","windowSize","scrollPos","zeroPoint","relativeScrollPosition","Math","min","max","scrollY","pageYOffset","documentElement","scrollTop","body","scrollX","pageXOffset","scrollLeft","_this2","activateImmediately","activeMediaQueryList","triggerFunction","classList","remove","triggerPosition","triggerTarget","triggerOnDeactivate","addListener","respond","scrollDetectorIsEmpty","triggerTargetIsEmpty","_this3","listener","requestUpdate","deactivate","ticking","_this4","requestAnimationFrame","test","activated","init","removeEventListener","trigger","matches","activate","_this5","unit","valueFormat","substitutionString","startValue","endValue","resetValue","scrollPosition","replace","toString","ScrollAnimation","animateTargets","_this6","defaultValueSets","valueSetSeparator","removePropertiesOnReset","startPosition","endPosition","Array","from","querySelectorAll","parentNode","err","listeners","_this7","add","updateCSS","push","e","cssValues","i","j","animateProperty","style","join","clampedRelativeScrollPosition","getCSSValue","setCSS","_this8","_this9","property","removeProperty","valueSet","reset","navigator","appName","RegExp","exec","userAgent","_this10","scrollPixelsPerParallaxPixel","_possibleConstructorReturn","_getPrototypeOf","call","target","_this11","dimensions","Size","_get","prototype","updateResizeCSS","index","filter","scrollTranslate","scrollTargetSize","parallaxSize","scrollTargetRect","scrollDistance","abs","valueSetsLength","animateTargetsLength","event","_this12"],"mappings":"mxCAAA,SAASA,EAAgBC,GAcxB,MAbiC,iBAAvBA,EAAQC,aACjBD,EAAQC,WAAa,CAAED,EAAQC,aAIF,WAA7BC,EAAOF,EAAQG,aACdH,EAAQG,qBAAqBC,GAC7BJ,EAAQG,qBAAqBE,KAG9BL,EAAQG,UAAY,CAAEH,EAAQG,YAGxBH,EAeR,SAASM,EAAwBC,GAChC,GAAGA,aAAeC,gBAA0B,OAARD,EACnC,OAAOA,EAGR,GAAkB,iBAARA,GAAoBA,EAC7B,OAAOE,OAAOC,WAAWH,GAG1B,MAAM,IAAII,EAAuBZ,EAAiB,2BAGnD,SAASa,EAAoBC,GAC5B,GAAIA,aAAcC,YACjB,OAAOD,EAGR,GAAkB,iBAAPA,EAAiB,CAG3B,KAFAA,EAAKE,SAASC,cAAcH,IAG3B,MAAM,IAAIF,EAAuBC,EAAqB,sBAGvD,OAAOC,EAGR,MAAM,IAAIF,EAAuBC,EAAqB,iBAGvD,SAASK,EAAwBC,EAAgBC,GAEhD,KAAKD,aAA0BE,GAC9B,QAA6B,IAAnBF,GAAmCA,GAEtC,GAA8B,iBAAnBA,GAA+BA,aAA0BJ,YAAa,CACvF,IAAIO,EAAeT,EAAoBM,GACvCA,EAAiB,IAAIE,EAAeC,QAC9B,GAA6B,WAA1BnB,EAAOgB,GAA6B,CAC7C,QAYyC,KADPlB,EAXHkB,GAYXI,uBAAoE,IAAzBtB,EAAQqB,aATtE,MAAM,IAAIV,EAAuB,KAAM,8BAA+B,GAAIY,QAAQC,MAAQ,cAF1FN,EAAiB,IAAIE,EAAeD,EAAqBD,SAN1DA,EAAiB,IAAIE,EAAeD,GAgBvC,IAAqCnB,EAHpC,OAAOkB,MAWFP,EASL,SAAAA,EAAYc,GAAoF,IAAlEC,EAAkEC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAA3D,UAAWG,EAAgDH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAzC,GAAII,EAAqCJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAA/BJ,QAAQS,OAAS,aAKjF,OAL+FC,EAAAC,KAAAvB,GAC/FuB,KAAKT,iBAAmBA,EACxBS,KAAKR,KAAOA,EACZQ,KAAKJ,KAAOA,GAEJ,GACP,KAAML,IAAqBL,GAA2B,oBAATM,EAC5CK,EAAI,wEACJ,MACD,KAAMN,IAAqBL,GAA2B,0BAATM,EAC5CK,EAAI,kEACJ,MACD,KAAMN,IAAqBL,GAA2B,sBAATM,EAC5CK,EAAI,kFACJ,MACD,KAAMN,IAAqBU,GAA0B,qBAATT,EAC3CK,EAAI,6EACJ,MACD,IAAe,4BAATL,EACLK,EAAI,+GACJ,MACD,IAAe,qBAATL,EACLK,EAAI,wOACJ,MACD,KAAMN,IAAqBpB,GAAsC,iBAATqB,EACvDK,EAAI,kDACJ,MACD,KAAMN,IAAqBW,GAA8B,8BAATV,EAC/CK,EAAI,6IAA8ID,EAAKO,cAAeP,EAAKT,cAC3K,MACD,IAAe,kBAATK,EACLK,EAAI,yEACJ,MACD,IAAe,uBAATL,EACLK,EAAI,sDACJ,MACD,IAAe,gCAATL,EACLK,EAAI,uHACJ,MACD,IAAe,2BAATL,EACLK,EAAI,4MACJ,MACD,QAEC,MADAA,EAAI,2DAA4DN,EAAkBC,EAAMI,GAClF,IAAInB,EAAuBuB,KAAKI,YAAa,4BAejDlB,aASL,SAAAA,EAAYpB,GAAS,IAAAuC,EAAAL,KAAAD,EAAAC,KAAAd,GACpBc,KAAKM,eAAiB,CACrBnB,aAAc,KACdC,kBAAkB,GAGnBtB,EAAUkC,KAAKnC,gBAAgBC,GAE/ByC,OAAOC,oBAAoBR,KAAKM,gBAAgBG,QAAQ,SAAAC,GACvDL,EAAKK,GAAQ5C,EAAQ4C,KAGtBV,KAAKW,yBACLpC,OAAOqC,iBAAiB,SAAUZ,KAAKW,wBACvCpC,OAAOqC,iBAAiB,OAAQZ,KAAKW,mFAOrCX,KAAKa,KAAOb,KAAKb,aAAa2B,wBAC9Bd,KAAKe,gBAAkB,CAACC,IAAKhB,KAAKa,KAAKG,IAAMhB,KAAKI,YAAYa,oBAAqBC,KAAMlB,KAAKa,KAAKK,KAAOlB,KAAKI,YAAYe,uBAC3HnB,KAAKoB,YAAc,CAAEC,MAAO9C,OAAO+C,WAAYC,OAAQhD,OAAOiD,qDAU/C1D,GASf,IARGA,aAAmBc,aAAkC,iBAAZd,KAC3CA,EAAU,CAAEqB,aAAcrB,IAGQ,iBAAzBA,EAAQqB,eACjBrB,EAAQqB,aAAeT,EAAoBZ,EAAQqB,iBAG/CrB,EAAQqB,wBAAwBP,aACpC,MAAM,IAAIH,EAAuBuB,KAAKI,YAAa,mBAGpD,OAAOG,OAAOkB,OAAO,GAAIzB,KAAKM,eAAgBxC,oDAY9C,IAAI4D,EAAQC,EAAMC,EAAYC,EAAWC,EAiBzC,OAfG9B,KAAKZ,kBACPyC,EAAY7B,KAAKI,YAAYa,oBAC7BS,EAAS1B,KAAKe,gBAAgBC,IAC9BW,EAAO3B,KAAKa,KAAKU,OACjBK,EAAa5B,KAAKoB,YAAYG,SAG9BM,EAAY7B,KAAKI,YAAYe,sBAC7BO,EAAS1B,KAAKe,gBAAgBG,KAC9BS,EAAO3B,KAAKa,KAAKQ,MACjBO,EAAa5B,KAAKoB,YAAYC,QAKvBQ,GAFRC,EAAYJ,EAASE,KACLF,EAASC,EACyBG,2DAcmC,IAAxDC,EAAwDtC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAA/BO,KAAK+B,yBAC3D,OAAOC,KAAKC,IAAID,KAAKE,IAAIH,EAAwB,GAAI,iDASrD,MAAG,YAAaxD,OACRA,OAAO4D,QACJ,gBAAiB5D,OACpBA,OAAO6D,YACJvD,SAASwD,gBAAgBC,UAAY,EACxCzD,SAASwD,gBAAgBC,UAEzBzD,SAAS0D,KAAKD,wDAUtB,MAAG,YAAa/D,OACRA,OAAOiE,QACJ,gBAAiBjE,OACpBA,OAAOkE,YACJ5D,SAASwD,gBAAgBK,WAAa,EACzC7D,SAASwD,gBAAgBK,WAEzB7D,SAAS0D,KAAKG,oBAQlBzC,aACL,SAAAA,IAA0B,IAAA0C,EAAA3C,KAAdlC,EAAc2B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GAAIM,EAAAC,KAAAC,GACzBnC,EAAUkC,KAAKnC,gBAAgBC,GAE/BkC,KAAKM,eAAiB,CACrBsC,qBAAqB,EACrBC,qBAAsB,qBACtB7D,eAAgB,KAChB8D,gBAAiB,SAASnE,GACzBA,EAAGoE,UAAUC,OAAO,cAErBC,gBAAiB,IACjBC,cAAe,KACfC,qBAAqB,GAGtB5C,OAAOC,oBAAoBR,KAAKM,gBAAgBG,QAAQ,SAAAC,GACvDiC,EAAKjC,GAAQ5C,EAAQ4C,KAGtBV,KAAK6C,qBAAqBO,YAAYpD,KAAKqD,SAExCrD,KAAK4C,qBACP5C,KAAKqD,4DAISvF,GACf,IAAIwF,OAA0D,IAA3BxF,EAAQkB,kBAAoClB,EAAQkB,eACnFuE,OAAwD,IAA1BzF,EAAQoF,iBAAmCpF,EAAQoF,cAErF,GAAGI,GAAyBC,EAC3B,MAAM,IAAI9E,EAAuBuB,KAAKI,YAAa,oBAepD,OAZGkD,GACFxF,EAAQoF,cAAgBxE,EAAoBZ,EAAQoF,eACpDpF,EAAQkB,eAAiB,IAAIE,EAAepB,EAAQoF,gBAC1CK,IACVzF,EAAQkB,eAAiBD,EAAwBjB,EAAQkB,eAAgB,MACzElB,EAAQoF,cAAgBpF,EAAQkB,eAAeG,eAGhDrB,EAAUyC,OAAOkB,OAAO,GAAIzB,KAAKM,eAAgBxC,IAEzC+E,qBAAuBzE,EAAwBN,EAAQ+E,sBAExD/E,iCAGD,IAAA0F,EAAAxD,KACNA,KAAKyD,SAAW,WACf,IAAI1B,EAAyByB,EAAKxE,eAAe+C,yBAC9CA,GAA0B,IAAOA,EAAyB,KAC5DyB,EAAKE,iBAIP1D,KAAKyD,WAELlF,OAAOqC,iBAAiB,SAAUZ,KAAKyD,UACvClF,OAAOqC,iBAAiB,SAAUZ,KAAKyD,4CAIvCzD,KAAK8C,gBAAgB9C,KAAKkD,8CAIvBlD,KAAKhB,eAAe+C,yBAA2B/B,KAAKiD,kBACtDjD,KAAKmD,qBAAsB,EAC3BnD,KAAK2D,cAGN3D,KAAK4D,SAAU,0CAQA,IAAAC,EAAA7D,KACXA,KAAK4D,SACRE,sBAAsB,WAAQD,EAAKE,SAGpC/D,KAAK4D,SAAU,qCASX5D,KAAKgE,YACRhE,KAAKiE,OACLjE,KAAKgE,WAAY,wCAKfhE,KAAKgE,YACPzF,OAAO2F,oBAAoB,SAAUlE,KAAKyD,UAC1ClF,OAAO2F,oBAAoB,SAAUlE,KAAKyD,UAEvCzD,KAAKmD,qBACPnD,KAAKmE,WAIPnE,KAAKgE,WAAY,oCASdhE,KAAK6C,qBAAqBuB,QAC5BpE,KAAKqE,WAELrE,KAAK2D,sBAUFzF,aAeL,SAAAA,EAAYJ,GAAS,IAAAwG,EAAAtE,KAAAD,EAAAC,KAAA9B,GAUpBJ,EAAUyC,OAAOkB,OAAO,GATH,CACpB8C,KAAM,KACNC,YAAa,2BACbC,mBAAoB,IACpBC,WAAY,GACZC,UAAW,GACXC,WAAY,GAG+B9G,GAE5CyC,OAAOC,oBAAoB1C,GAAS2C,QAAQ,SAAAC,GAC3C4D,EAAK5D,GAAQ5C,EAAQ4C,mDAIXmE,GACX,OAAO7E,KAAKwE,YAAYM,QAAQ9E,KAAKyE,qBAAsBzE,KAAK2E,SAAW3E,KAAK0E,YAAcG,EAAiB7E,KAAK0E,YAAYK,WAAa/E,KAAKuE,eAO9IS,aAqBL,SAAAA,EAAYC,EAAgBjG,EAAgBlB,GAA+D,IAAAoH,EAAAlF,KAAtDmF,EAAsD1F,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAnC,CAAE,IAAIvB,GAA6B6B,EAAAC,KAAAgF,GAC1G,IAAI1E,EAAiB,CACpBvC,WAAY,CAAC,YAAa,eAC1BE,UAAWkH,EACXC,kBAAmB,IACnBC,yBAAyB,EACzBxC,qBAAsBtE,OAAOC,WAAW,sBACxCoE,qBAAqB,EACrB0C,cAAe,EACfC,YAAa,GAIXN,aAA0BrG,YAC5BqG,EAAiB,CAACA,GACiB,iBAAnBA,IAChBA,EAAiBO,MAAMC,KAAK5G,SAAS6G,iBAAiBT,KAGvD,IACCjG,EAAiBD,EAAwBC,EAAgBiG,EAAe,GAAGU,YAC1E,MAAMC,GACP,GAAgB,gCAAbA,EAAIpG,KAAwC,CAC9C,QAAsB,IAAZ1B,EAIT,MAAM,IAAIW,EAAuBuB,KAAKI,YAAa,oBAHnDtC,EAAUkB,EACVA,EAAiB,IAAIE,EAAe+F,EAAe,GAAGU,kBAOnC,IAAZ7H,IACTA,EAAUD,EAAgBC,EAASkC,KAAKI,cAGzCtC,EAAUyC,OAAOkB,OAAO,GAAInB,EAAgBxC,GAE5CyC,OAAOC,oBAAoBF,GAAgBG,QAAQ,SAAAC,GAClDwE,EAAKxE,GAAQ5C,EAAQ4C,KAGtBV,KAAKiF,eAAiBA,EACtBjF,KAAKhB,eAAiBA,EACtBgB,KAAK6F,UAAY,GACjB7F,KAAK4D,SAAU,EACf5D,KAAKgE,WAAY,EAEdhE,KAAK4C,qBACP5C,KAAKqD,UAGNrD,KAAK6C,qBAAqBO,YAAYpD,KAAKqD,kDAQrC,IAAAyC,EAAA9F,KACNA,KAAKiF,eAAexE,QAAQ,SAAAN,GAC3BA,EAAc4C,UAAUgD,IAAI,mBAC5BD,EAAKE,YAELF,EAAKD,UAAUI,KAAK,SAACC,GACpB,IAAInE,EAAyB+D,EAAK9G,eAAe+C,yBAC9CA,GAA0B,IAAOA,EAAyB,KAC5D+D,EAAKpC,cAAcwC,KAIrB3H,OAAOqC,iBAAiB,SAAUkF,EAAKD,UAAUC,EAAKD,UAAUnG,OAAS,IACzEnB,OAAOqC,iBAAiB,SAAUkF,EAAKD,UAAUC,EAAKD,UAAUnG,OAAS,qCASpEyG,GACN,IAAI,IAAIC,EAAI,EAAGA,EAAIpG,KAAKiF,eAAevF,OAAQ0G,IAG9C,IAFA,IAAIjG,EAAgBH,KAAKiF,eAAemB,GAEhCC,EAAI,EAAGA,EAAIrG,KAAKjC,WAAW2B,OAAQ2G,IAAK,CAC/C,IAAIC,EAAkBtG,KAAKjC,WAAWsI,GACtClG,EAAcoG,MAAMD,GAAmBH,EAAUK,KAAKxG,KAAKoF,wDAO7DpF,KAAK4D,SAAU,EAMf,IALA,IAAIuC,EAAY,GAEZtB,EAAiB7E,KAAKhB,eAAeyH,gCAErC/G,EAASM,KAAK/B,UAAUyB,OACpB0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IAC1BD,EAAUF,KAAMjG,KAAK/B,UAAUmI,GAAGM,YAAY7B,IAG/C7E,KAAK2G,OAAOR,2CAQG,IAAAS,EAAA5G,KACXA,KAAK4D,SACRE,sBAAsB,WAAQ8C,EAAKZ,cAGpChG,KAAK4D,SAAU,kCAQR,IAmBHwC,EAnBGS,EAAA7G,KACP,GAAGA,KAAKqF,wBACPrF,KAAKiF,eAAexE,QAAQ,SAAAN,GAC3B0G,EAAK9I,WAAW0C,QAAQ,SAAAqG,GACvB3G,EAAcoG,MAAMQ,eAAeD,WAG/B,CACN,IAAIX,EAAY,GAEhBnG,KAAK/B,UAAUwC,QAAQ,SAAAuG,GACtBb,EAAUF,KACTe,EAASxC,YAAYM,QAAQkC,EAASvC,mBAAoBuC,EAASpC,WAAWG,WAAaiC,EAASzC,SAItGvE,KAAK2G,OAAOR,GAIb,IAAIzG,EAASM,KAAKiF,eAAevF,OAEjC,IAAI0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IACtBpG,KAAKiF,eAAemB,GAAGrD,UAAUC,OAAO,sDAUrChD,KAAKgE,YACRhE,KAAKiE,OACLjE,KAAKgE,WAAY,wCAUfhE,KAAKgE,WACPhE,KAAK6F,UAAUpF,QAAQ,SAAAgD,GACtBlF,OAAO2F,oBAAoB,SAAUT,GACrClF,OAAO2F,oBAAoB,SAAUT,KAIvCzD,KAAKiH,QACLjH,KAAKgE,WAAY,oCASdhE,KAAK6C,qBAAqBuB,QAC5BpE,KAAKqE,WAELrE,KAAK2D,8CAKN,MACwB,gCAAtBuD,UAAUC,SAAsE,aAAtBD,UAAUC,SAA2G,OAA/E,IAAIC,OAAO,sCAAsCC,KAAKH,UAAUI,oBAQ9JnJ,EAcL,SAAAA,EAAYL,GAAS,IAAAyJ,EAAAvH,KAAAD,EAAAC,KAAA7B,GACpB,IAAImC,EAAiB,CACpBkE,YAAa,2BACbC,mBAAoB,IACpB+C,6BAA8B,GAC9B5C,WAAY,GASb,GANA9G,EAAUyC,OAAOkB,OAAO,GAAInB,EAAgBxC,GAE5CyC,OAAOC,oBAAoBF,GAAgBG,QAAQ,SAAAC,GAClD6G,EAAK7G,GAAQ5C,EAAQ4C,KAGmB,IAAtCV,KAAKwH,6BACP,MAAM,IAAI/I,EAAuBuB,KAAKI,YAAa,iBAQhDF,cAuBL,SAAAA,EAAY+E,EAAgBjG,EAAgBlB,GAA0D,IAAjDG,EAAiDwB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAArC,CAAE,IAAItB,GAA+B,OAAA4B,EAAAC,KAAAE,GAAAuH,EAAAzH,KAAA0H,EAAAxH,GAAAyH,KAAA3H,KAC/FiF,EAAgBjG,EAAgBlB,EAASG,gPAxBjB+G,qCAgCxB,IAkBFoB,EACAwB,EAnBEC,EAAA7H,KACNA,KAAK8H,WACJ9H,KAAKhB,eAAeI,iBACpB,CAAEuC,KAAM,SAAUoG,KAAM,SAAUrG,OAAQ,OAC1C,CAAEC,KAAM,QAASoG,KAAM,QAASrG,OAAQ,QAGzC1B,KAAKW,yBAELqH,EAAAN,EAAAxH,EAAA+H,WAAA,OAAAjI,MAAA2H,KAAA3H,MAEAA,KAAKhB,eAAeG,aAAa4D,UAAUgD,IAAI,sBAE/CxH,OAAOqC,iBAAiB,OAAQ,WAC/BiH,EAAKK,kBACLL,EAAK7B,cAKN,IAAItG,EAASM,KAAKiF,eAAevF,OAEjC,IACC,IAAI0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IAKtB,IAJAwB,EAAS5H,KAAKiF,eAAemB,IAEtBrD,UAAUgD,IAAI,qBAElB6B,EAAOjC,aAAe3F,KAAKhB,eAAeG,aAC5C,MAAM,IAAIV,EAAuBuB,KAAKI,YAAa,4BAA6B,CAAC+H,MAAO/B,EAAGjG,cAAeyH,EAAQzI,aAAca,KAAKhB,eAAeG,eAGrJ,MAAMyG,GACP5F,KAAK2D,aAEL3D,KAAKiF,eAAiBjF,KAAKiF,eAAemD,OAAO,SAACR,GACtChC,EAAIzF,gBAGbH,KAAKiF,eAAevF,QACtBM,KAAKqE,gDAgBP,IALA,IAAIQ,EAAiB7E,KAAKhB,eAAeyH,gCAErCN,EAAY,GAEZzG,EAASM,KAAK/B,UAAUyB,OACpB0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IAAK,CAC/B,IAAIiC,EAGHA,EADErI,KAAK/B,UAAUmI,GAAGoB,6BAA+B,IAC9BxH,KAAKsI,iBAAmBtI,KAAK/B,UAAUmI,GAAGmC,eAAiB,EAAI1D,KAE/D7E,KAAKsI,iBAAmBtI,KAAK/B,UAAUmI,GAAGmC,cAAgB1D,EAGhFsB,EAAUF,KACTjG,KAAK/B,UAAUmI,GAAG5B,YAAYM,QAAQ9E,KAAK/B,UAAUmI,GAAG3B,mBAAoB4D,EAAgBtD,WAAa,OAI3G/E,KAAK2G,OAAOR,GACZnG,KAAK4D,SAAU,mDAIf5D,KAAKwI,iBAAmBxI,KAAKhB,eAAeG,aAAa2B,wBACzDd,KAAKsI,iBAAmBtI,KAAKwI,iBAAiBxI,KAAK8H,WAAWnG,MAC9D3B,KAAKyI,eAAiBzI,KAAKsI,iBAAmB/J,OAAO,QAAUyB,KAAK8H,WAAWC,MAG/E,IADA,IAAIrI,EAASM,KAAK/B,UAAUyB,OACnB0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IAC3BpG,KAAK/B,UAAUmI,GAAGmC,aAAevG,KAAK0G,IAAI1I,KAAKyI,eAAiBzI,KAAK/B,UAAUmI,GAAGoB,8BAAgCxH,KAAKsI,2DAKxHtI,KAAKW,yBAKL,IAHA,IAAIgI,EAAkB3I,KAAK/B,UAAUyB,OACjCkJ,EAAuB5I,KAAKiF,eAAevF,OAEtC0G,EAAI,EAAGA,EAAIuC,EAAiBvC,IACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIuC,EAAsBvC,IACzCrG,KAAKiF,eAAeoB,GAAGE,MAAMvG,KAAK8H,WAAWnG,MAAQ3B,KAAK/B,UAAUmI,GAAGmC,aAAaxD,WAAa,2CAKtF8D,GAAO,IAAAC,EAAA9I,KAChBA,KAAK4D,SACRE,sBAAsB,WACrBgF,EAAK9C,YAEa,WAAf6C,EAAMrJ,MACRsJ,EAAKZ,oBAKRlI,KAAK4D,SAAU,kCAIf,IAAIwC,EACA1G,EAASM,KAAKiF,eAAevF,OAEjC,IAAI0G,EAAI,EAAGA,EAAI1G,EAAQ0G,IACtBpG,KAAKiF,eAAemB,GAAGG,MAAMQ,eAAe,UAC5C/G,KAAKiF,eAAemB,GAAGrD,UAAUC,OAAO,qBACxChD,KAAKiF,eAAemB,GAAGT,WAAW5C,UAAUC,OAAO,mBAGpDgF,EAAAN,EAAAxH,EAAA+H,WAAA,QAAAjI,MAAA2H,KAAA3H,MAEAA,KAAKhB,eAAeG,aAAa4D,UAAUC,OAAO","sourcesContent":["function validateOptions(options) {\n\tif(typeof options.properties === 'string') {\n\t\toptions.properties = [ options.properties ];\n\t}\n\n\tif(\n\t\ttypeof options.valueSets === 'object' && (\n\t\t\toptions.valueSets instanceof ScrollAnimationValueSet ||\n\t\t\toptions.valueSets instanceof ParallaxAnimationValueSet\n\t\t)\n\t) {\n\t\toptions.valueSets = [ options.valueSets ];\n\t}\n\n\treturn options;\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction arrayify(obj) {\n\treturn (obj instanceof Array || obj instanceof NodeList) ? obj : [ obj ];\n}\n\n/**\n * Handle strings provided where a MediaQueryList is expected\n *\n * @param {[type]} mql\n *\n * @return {[type]}\n */\nfunction normalizeMediaQueryList(mql) {\n\tif(mql instanceof MediaQueryList || mql === null) {\n\t\treturn mql;\n\t}\n\n\tif(typeof mql === 'string' && mql) {\n\t\treturn window.matchMedia(mql);\n\t}\n\n\tthrow new ParallaxativeException(validateOptions, 'badActiveMediaQueryList');\n}\n\nfunction normalizeDOMElement(el) {\n\tif (el instanceof HTMLElement) {\n\t\treturn el;\n\t}\n\n\tif (typeof el === 'string') {\n\t\tel = document.querySelector(el);\n\n\t\tif(!el) {\n\t\t\tthrow new ParallaxativeException(normalizeDOMElement, 'emptySelectorQuery');\n\t\t}\n\n\t\treturn el;\n\t}\n\n\tthrow new ParallaxativeException(normalizeDOMElement, 'badDOMElement');\n}\n\nfunction normalizeScrollDetector(scrollDetector, defaultScrollTarget) {\n\n\tif(!(scrollDetector instanceof ScrollDetector)) {\n\t\tif(typeof scrollDetector === 'undefined' || !scrollDetector) { // Allow passing nothing\n\t\t\tscrollDetector = new ScrollDetector(defaultScrollTarget);\n\t\t} else if (typeof scrollDetector === 'string' || scrollDetector instanceof HTMLElement) {\n\t\t\tlet scrollTarget = normalizeDOMElement(scrollDetector);\n\t\t\tscrollDetector = new ScrollDetector(scrollTarget);\n\t\t} else if(typeof scrollDetector === 'object') { // Allow passing ScrollDetector's OR ScrollAnimation's options\n\t\t\tif(optionsAreForScrollDetector(scrollDetector)) {\n\t\t\t\tscrollDetector = new ScrollDetector(defaultScrollTarget, scrollDetector);\n\t\t\t} else {\n\t\t\t\tthrow new ParallaxativeException(null, 'optionsNotForScrollDetector', {}, console.warn || function(){});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scrollDetector;\n}\n\nfunction optionsAreForScrollDetector(options) {\n\treturn typeof options.scrollIsVertical !== 'undefined' || typeof options.scrollTarget !== 'undefined';\n}\n\n\n/**\n * Class for all errors in other Parallaxative classes.\n */\nclass ParallaxativeException {\n\t/**\n\t * Creates a ParallaxativeException.\n\t *\n\t * @param {function} throwingFunction - The class where the error occurred.\n\t * @param {string} [type='generic'] - Error code associated with plain-English help text.\n\t * @param {Object} [data={}] - Arbitrary data provided with the error.\n\t * @param {string} [log=console.error || function(){}] - Function with which to log the error.\n\t */\n\tconstructor(throwingFunction, type = 'generic', data = {}, log = console.error || function(){}) {\n\t\tthis.throwingFunction = throwingFunction;\n\t\tthis.type = type;\n\t\tthis.data = data;\n\n\t\tswitch (true) {\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'badScrollTarget'):\n\t\t\t\tlog('scrollTarget must be a query selector string or an HTMLElement node.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'scrollTargetQueryNull'):\n\t\t\t\tlog('scrollTarget query selector string did not match any elements.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'scrollTargetEmpty'):\n\t\t\t\tlog('scrollTarget was not provided, was empty, or did not resolve to a DOM element.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollTrigger && type === 'noTriggerElement'):\n\t\t\t\tlog('You must provide ScrollTarget either a scrollDetector or a triggerTarget.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'badActiveMediaQueryList'):\n\t\t\t\tlog('activeMediaQueryList, if provided at all, must be either a media query string or a MediaQueryList instance.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'duplicateOptions'):\n\t\t\t\tlog('ScrollAnimation’s second parameter looked like it was options for ScrollAnimation, but other options were provided in the third parameter. If the third parameter is present, the second parameter must pertain to a ScrollDetector.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ParallaxAnimationValueSet && type === 'divideByZero'):\n\t\t\t\tlog('scrollPixelsPerParallaxPixel must not be zero.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ParallaxAnimation && type === 'overlyNestedAnimateTarget'):\n\t\t\t\tlog('Parallax animateTarget %o is nested too many levels beneath scrollTarget %o. The animateTarget must be a direct child of the scrollTarget.', data.animateTarget, data.scrollTarget);\n\t\t\t\tbreak;\n\t\t\tcase (type === 'badDOMElement'):\n\t\t\t\tlog('A Parallaxative class couldn’t convert your input into an HTMLElement');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'emptySelectorQuery'):\n\t\t\t\tlog('Your query selector didn’t match any DOM elements.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'optionsNotForScrollDetector'):\n\t\t\t\tlog('Options in a scrollDetector parameter were not for a scrollDetector and were not detected to be for something else.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'unhandledExceptionType'):\n\t\t\t\tlog('The previous error was not handled specifically (with plain English error text). This is the Parallaxative developer’s fault, and you should yell at him at https://github.com/75th/parallaxative/issues');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog('Error in Parallaxative class %o of type %o with data %o.', throwingFunction, type, data);\n\t\t\t\tthrow new ParallaxativeException(this.constructor, 'unhandledExceptionType');\n\t\t}\n\t}\n}\n\n/**\n * Options for a ScrollDetector.\n * @typedef {Object|HTMLElement|string} ScrollDetectorOptions - Either an object with the below properties, or an HTMLElement or a querySelector string for the scrollTarget property.\n * @property {HTMLElement|string} scrollTarget - Either the element whose position to track, or a querySelector string pointing to it.\n * @property {boolean} [scrollIsVertical=true] - Whether to track vertical scrolling instead of horizontal scrolling.\n */\n\n/**\n * Tracks the relative position of an element as it scrolls by.\n */\nclass ScrollDetector {\n\t/**\n\t * Create a ScrollDetector.\n\t *\n\t * @param {HTMLElement} scrollTarget - Element whose position to track\n\t * @param {ScrollDetectorOptions} options\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(options) {\n\t\tthis.defaultOptions = {\n\t\t\tscrollTarget: null,\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\toptions = this.validateOptions(options);\n\n\t\tObject.getOwnPropertyNames(this.defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.updateResizeProperties();\n\t\twindow.addEventListener('resize', this.updateResizeProperties);\n\t\twindow.addEventListener('load', this.updateResizeProperties);\n\t}\n\n\t/**\n\t * Event handler to update internal state when the window size changes.0\n\t */\n\tupdateResizeProperties() {\n\t\tthis.rect = this.scrollTarget.getBoundingClientRect();\n\t\tthis.documentOffsets = {top: this.rect.top + this.constructor.getVerticalScroll(), left: this.rect.left + this.constructor.getHorizontalScroll() };\n\t\tthis.windowSizes = { width: window.innerWidth, height: window.innerHeight };\n\t}\n\n\t/**\n\t * [validateOptions description]\n\t *\n\t * @param {[type]} options\n\t *\n\t * @return {[type]}\n\t */\n\tvalidateOptions(options) {\n\t\tif(options instanceof HTMLElement || typeof options === 'string') { // Allow providing bare DOM node\n\t\t\toptions = { scrollTarget: options };\n\t\t}\n\n\t\tif(typeof options.scrollTarget === 'string') {\n\t\t\toptions.scrollTarget = normalizeDOMElement(options.scrollTarget);\n\t\t}\n\n\t\tif(!(options.scrollTarget instanceof HTMLElement)) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'badScrollTarget');\n\t\t}\n\n\t\treturn Object.assign({}, this.defaultOptions, options);\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos, zeroPoint, completePoint;\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscrollPos = this.constructor.getVerticalScroll();\n\t\t\toffset = this.documentOffsets.top;\n\t\t\tsize = this.rect.height;\n\t\t\twindowSize = this.windowSizes.height;\n\n\t\t} else {\n\t\t\tscrollPos = this.constructor.getHorizontalScroll();\n\t\t\toffset = this.documentOffsets.left;\n\t\t\tsize = this.rect.width;\n\t\t\twindowSize = this.windowSizes.width;\n\t\t}\n\n\t\tzeroPoint = offset - windowSize;\n\t\tcompletePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tstatic getVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tstatic getHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}\n\n/**\n * Run a function based on a ScrollDetector\n */\nclass ScrollTrigger {\n\tconstructor(options = {}) {\n\t\toptions = this.validateOptions(options);\n\n\t\tthis.defaultOptions = {\n\t\t\tactivateImmediately: true,\n\t\t\tactiveMediaQueryList: '(min-width: 720px)',\n\t\t\tscrollDetector: null, // Handled above\n\t\t\ttriggerFunction: function(el) {\n\t\t\t\tel.classList.remove('offscreen');\n\t\t\t},\n\t\t\ttriggerPosition: 0.15,\n\t\t\ttriggerTarget: null, // Handled above\n\t\t\ttriggerOnDeactivate: true\n\t\t};\n\n\t\tObject.getOwnPropertyNames(this.defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.activeMediaQueryList.addListener(this.respond);\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\t}\n\n\tvalidateOptions(options) {\n\t\tvar scrollDetectorIsEmpty = typeof options.scrollDetector === 'undefined' || !!options.scrollDetector;\n\t\tvar triggerTargetIsEmpty = typeof options.triggerTarget === 'undefined' || !!options.triggerTarget;\n\n\t\tif(scrollDetectorIsEmpty && triggerTargetIsEmpty) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'noTriggerElement');\n\t\t}\n\n\t\tif(scrollDetectorIsEmpty) {\n\t\t\toptions.triggerTarget = normalizeDOMElement(options.triggerTarget);\n\t\t\toptions.scrollDetector = new ScrollDetector(options.triggerTarget);\n\t\t} else if (triggerTargetIsEmpty) {\n\t\t\toptions.scrollDetector = normalizeScrollDetector(options.scrollDetector, null);\n\t\t\toptions.triggerTarget = options.scrollDetector.scrollTarget;\n\t\t}\n\n\t\toptions = Object.assign({}, this.defaultOptions, options);\n\n\t\toptions.activeMediaQueryList = normalizeMediaQueryList(options.activeMediaQueryList);\n\n\t\treturn options;\n\t}\n\n\tinit() {\n\t\tthis.listener = () => {\n\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\tthis.requestUpdate();\n\t\t\t}\n\t\t};\n\n\t\tthis.listener();\n\n\t\twindow.addEventListener('scroll', this.listener);\n\t\twindow.addEventListener('resize', this.listener);\n\t}\n\n\ttrigger() {\n\t\tthis.triggerFunction(this.triggerTarget);\n\t}\n\n\ttest() {\n\t\tif(this.scrollDetector.relativeScrollPosition() > this.triggerPosition) {\n\t\t\tthis.triggerOnDeactivate = true;\n\t\t\tthis.deactivate();\n\t\t}\n\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.test(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\twindow.removeEventListener('scroll', this.listener);\n\t\t\twindow.removeEventListener('resize', this.listener);\n\n\t\t\tif(this.triggerOnDeactivate) {\n\t\t\t\tthis.trigger();\n\t\t\t}\n\t\t}\n\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n\n/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nclass ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\tgetCSSValue(scrollPosition) {\n\t\treturn this.valueFormat.replace(this.substitutionString, ((this.endValue - this.startValue) * scrollPosition + this.startValue).toString() + this.unit);\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nclass ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector. May also be a single bare HTMLElement\n\t *         or a query selector string\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {array<ScrollAnimationValueSet>} valueSets: Configuration for one or more values to be modified within a single CSS rule\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t */\n\tconstructor(animateTargets, scrollDetector, options, defaultValueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSets: defaultValueSets,\n\t\t\tvalueSetSeparator: ' ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\tstartPosition: 0, // FIXME: Not implemented\n\t\t\tendPosition: 1 // FIXME: Not implemented\n\t\t};\n\n\t\t// Syntax sugar for animateTargets\n\t\tif(animateTargets instanceof HTMLElement) { // Allow passing bare DOM node\n\t\t\tanimateTargets = [animateTargets];\n\t\t} else if(typeof animateTargets === 'string') { // Allow passing query selector string\n\t\t\tanimateTargets = Array.from(document.querySelectorAll(animateTargets));\n\t\t}\n\n\t\ttry {\n\t\t\tscrollDetector = normalizeScrollDetector(scrollDetector, animateTargets[0].parentNode, options);\n\t\t} catch(err) {\n\t\t\tif(err.type === 'optionsNotForScrollDetector') {\n\t\t\t\tif(typeof options === 'undefined') {\n\t\t\t\t\toptions = scrollDetector;\n\t\t\t\t\tscrollDetector = new ScrollDetector(animateTargets[0].parentNode);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ParallaxativeException(this.constructor, 'duplicateOptions');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(typeof options !== 'undefined') {\n\t\t\toptions = validateOptions(options, this.constructor);\n\t\t}\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(this.respond);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tthis.ticking = false;\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tcssValues.push( this.valueSets[i].getCSSValue(scrollPosition) );\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\n\t\tvar i;\n\t\tvar length = this.animateTargets.length;\n\n\t\tfor(i = 0; i < length; i++) {\n\t\t\tthis.animateTargets[i].classList.remove('scroll-animated');\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t\twindow.removeEventListener('resize', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n\n\tstatic isIE() {\n\t\treturn (\n\t\t\t(navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))\n\t\t);\n\t}\n}\n\n/**\n * Default option container for ParallaxAnimation CSS values.\n */\nclass ParallaxAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel === 0) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'divideByZero');\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxAnimationValueSet() ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.dimensions =\n\t\t\tthis.scrollDetector.scrollIsVertical ?\n\t\t\t{ size: 'height', Size: 'Height', offset: 'top' } :\n\t\t\t{ size: 'width', Size: 'Width', offset: 'left' }\n\t\t;\n\n\t\tthis.updateResizeProperties();\n\n\t\tsuper.init();\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallax-container');\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeCSS();\n\t\t\tthis.updateCSS();\n\t\t});\n\n\t\tvar i;\n\t\tvar target;\n\t\tvar length = this.animateTargets.length;\n\n\t\ttry {\n\t\t\tfor(i = 0; i < length; i++) {\n\t\t\t\ttarget = this.animateTargets[i];\n\n\t\t\t\ttarget.classList.add('parallax-animated');\n\n\t\t\t\tif(target.parentNode !== this.scrollDetector.scrollTarget) {\n\t\t\t\t\tthrow new ParallaxativeException(this.constructor, 'overlyNestedAnimateTarget', {index: i, animateTarget: target, scrollTarget: this.scrollDetector.scrollTarget });\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(err) {\n\t\t\tthis.deactivate();\n\n\t\t\tthis.animateTargets = this.animateTargets.filter((target) => {\n\t\t\t\ttarget !== err.animateTarget;\n\t\t\t});\n\n\t\t\tif(this.animateTargets.length) {\n\t\t\t\tthis.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar cssValues = [];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tvar scrollTranslate;\n\n\t\t\tif(this.valueSets[i].scrollPixelsPerParallaxPixel < 0) {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * (1 - scrollPosition));\n\t\t\t} else {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * scrollPosition);\n\t\t\t}\n\n\t\t\tcssValues.push(\n\t\t\t\tthis.valueSets[i].valueFormat.replace(this.valueSets[i].substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tthis.scrollTargetSize = this.scrollTargetRect[this.dimensions.size];\n\t\tthis.scrollDistance = this.scrollTargetSize + window['inner' + this.dimensions.Size];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.valueSets[i].parallaxSize = Math.abs(this.scrollDistance / this.valueSets[i].scrollPixelsPerParallaxPixel) + this.scrollTargetSize;\n\t\t}\n\t}\n\n\tupdateResizeCSS() {\n\t\tthis.updateResizeProperties();\n\n\t\tvar valueSetsLength = this.valueSets.length;\n\t\tvar animateTargetsLength = this.animateTargets.length;\n\n\t\tfor (var i = 0; i < valueSetsLength; i++) {\n\t\t\tfor (var j = 0; j < animateTargetsLength; j++) {\n\t\t\t\tthis.animateTargets[j].style[this.dimensions.size] = this.valueSets[i].parallaxSize.toString() + 'px';\n\t\t\t}\n\t\t}\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\treset() {\n\t\tvar i;\n\t\tvar length = this.animateTargets.length;\n\n\t\tfor(i = 0; i < length; i++) {\n\t\t\tthis.animateTargets[i].style.removeProperty('height');\n\t\t\tthis.animateTargets[i].classList.remove('parallax-animated');\n\t\t\tthis.animateTargets[i].parentNode.classList.remove('parallax-anchor');\n\t\t}\n\n\t\tsuper.reset();\n\n\t\tthis.scrollDetector.scrollTarget.classList.remove('parallax-container');\n\t}\n}\n\nexport { ScrollDetector, ScrollTrigger, ScrollAnimation, ScrollAnimationValueSet, ParallaxAnimation, ParallaxAnimationValueSet };"]}