{"version":3,"sources":["webpack:///webpack/bootstrap c29502c5f77f4f834127","webpack:///./src/parallaxative.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;skBC7DA,2lB,eAeC,sBAAY,EAAuB,mCAClC,MACC,sBAGD,QAAK,aAEL,IAAU,OAAc,UAAI,EAE5B,UAAO,oBAAoB,GAAS,QAAQ,SAC3C,KAAK,GAAQ,EAGd,UAEA,gCAAO,iBAAiB,SACvB,aAGD,kCAAO,iBAAiB,OACvB,aAED,sFAGA,gBAAK,KAAO,KAAK,aACjB,6BAAuB,iBAAC,IAAK,KAAK,KAAK,IAAM,KAAK,YAAY,oBAAqB,KAAM,KAAK,KAAK,KAAO,KAAK,YAC/G,4BAAmB,aAAE,MAAO,OAAO,WAAY,OAAQ,OAGxD,mDASC,cAAI,GAAQ,EAAM,EAAY,EAAW,EAEzC,CAeO,OAfJ,MACF,oBAAY,KAAK,YACjB,sBAAS,KAAK,gBACd,MAAO,KAAK,KACZ,SAAa,KAAK,YAGlB,WAAY,KAAK,YACjB,wBAAS,KAAK,gBACd,OAAO,KAAK,KACZ,QAAa,KAAK,YAGnB,SAAY,EACZ,IAAgB,EAChB,GAAQ,EAAY,IAAc,EAInC,gDAUsF,wEAA/B,KACtD,+BAAO,MAAK,IAAI,KAAK,IAAI,EAAwB,GAGlD,sCAMC,iBAAG,WACF,QAAO,OACD,QAAI,eACV,QAAO,OACD,YAAI,SAAS,gBAAgB,UACnC,EAAO,SAAS,gBAEhB,UAAO,SAAS,KAIlB,6CAMC,iBAAG,WACF,QAAO,OACD,QAAI,eACV,QAAO,OACD,YAAI,SAAS,gBAAgB,WACnC,EAAO,SAAS,gBAEhB,WAAO,SAAS,KAEjB,eAGF,K,cAIC,sBAAuF,mIAA7B,EAA6B,kCACtF,MACC,yBAAsB,OAAO,WAC7B,2CACA,kBACA,oBAAiB,SAChB,KAAG,UAAU,OAEd,mCAGD,KAAU,OAAc,UAAI,EAE5B,UAAO,oBAAoB,GAAS,QAAQ,SAC3C,KAAK,GAAQ,EAGd,UAAK,eACL,OAAK,cAEL,OAAK,qBAAqB,YACzB,aAGD,YAAG,KACF,0BAED,mDAEM,iBACN,UAAK,SACJ,cAAI,GAAyB,EAAK,eAClC,wBAA4B,IAAC,IAAO,EACnC,OAIF,sBAEA,kBAAO,iBAAiB,SAAU,KAClC,iBAAO,iBAAiB,SAAU,KAClC,iCAGA,gBAAK,gBAAgB,KACrB,mCAGA,WAAG,KAAK,eAAe,yBAA2B,KACjD,uBAAK,qBACL,OAGD,mBAAK,SAGN,+BAKgB,iBACZ,IAAC,MACH,+BAA8B,aAG/B,cAAK,SAGN,0BAMI,WAAC,KACH,iBACA,YAAK,WAEN,6BAGA,WAAG,KACF,mBAAO,oBAAoB,SAAU,KACrC,iBAAO,oBAAoB,SAAU,KAErC,UAAG,KACF,0BAIF,gBAAK,WAGN,yBAMC,WAAG,KAAK,qBACP,aAEA,gBAED,iBAIF,K,wBAmBC,sBAAqB,mCACpB,MACC,SACA,iBACA,8CACA,eACA,GAAU,UACV,cAGD,KAAU,OAAc,UAAI,EAE5B,UAAO,oBAAoB,GAAS,QAAQ,SAC3C,KAAK,GAAQ,EAEd,8D,SAGO,MAAK,YAAY,QAAQ,KAA0B,qBAAC,KAAK,SAAW,KAAK,YAAc,EAAiB,KAAK,YAAY,WAAa,KAC7I,UAGF,K,gBA0BC,sBAAY,EAAgB,EAAwE,oEAAnC,IAAE,GAAiC,+CACnG,MACC,IAAY,YAAC,YACb,iCACA,6BACA,uBAAsB,OAAO,WAC7B,2CACA,gBACA,cAGD,KAAU,OAAc,UAAI,EAE5B,UAAO,oBAAoB,GAAS,QAAQ,SAC3C,KAAK,GAAQ,EAGd,UAAK,eACL,OAAK,eACL,OAAK,UACL,OACA,kBAAK,SACL,OAAK,WAEL,EAAG,KACF,0BAGD,eAAK,qBAAqB,YACzB,aAIF,qDAKO,iBACN,UAAK,eAAe,QAAQ,SAC3B,KAAc,UAAU,IACxB,qBAEA,cAAK,UAAU,KAAK,SACnB,MAAI,GAAyB,EAAK,eAClC,wBAA4B,IAAC,IAAO,EACnC,OAAK,cAIP,YAAO,iBAAiB,SAAU,EAAK,UAAU,EAAK,UAAU,OAChE,WAAO,iBAAiB,SAAU,EAAK,UAAU,EAAK,UAAU,OAIlE,qC,OAMK,GAAI,GAAI,EAAG,EAAI,KAAK,eAAe,OACtC,QAEI,GAFA,GAAgB,KAAK,eAEzB,GAAQ,EAAI,EAAG,EAAI,KAAK,WAAW,OAAQ,IAC1C,IAAI,GAAkB,KAAK,WAC3B,KAAc,MAAM,GAAmB,EAAU,KAAK,KAGxD,6CAIA,gBAAK,SACL,MAKI,GAHJ,MAAI,EAAiB,KAAK,eAE1B,gCAAI,EAAS,KAAK,UAClB,OAAQ,EAAI,EAAG,EAAI,EAClB,MAAU,KAAM,KAAK,UAAU,GAAG,YAGnC,SAAK,OAGN,gCAKgB,iBACZ,IAAC,MACH,+BAA8B,aAG/B,mBAAK,SAGN,uBAKQ,iBACP,QAAG,KACF,6BAAK,eAAe,QAAQ,SAC3B,KAAK,WAAW,QAAQ,SACvB,KAAc,MAAM,eAGtB,WACA,IAEA,WAAK,UAAU,QAAQ,SACtB,KAAU,KACT,EAAS,YAAY,QAAQ,EAAS,mBAAoB,EAAS,WAAW,WAAa,EAI7F,cAAK,OAIP,4BAMI,WAAC,KACH,iBACA,YAAK,WAIP,6BAMC,WAAG,KACF,gBAAK,UAAU,QAAQ,SACtB,UAAO,oBAAoB,SAC3B,UAAO,oBAAoB,SAI7B,UACA,aAAK,WAGN,yBAMC,WAAG,KAAK,qBACP,aAEA,gBAED,mCAGA,iBACwB,gCAAtB,UAAU,SAAsE,aAAtB,UAAU,SAEtE,OAFkG,GAAI,QAAO,sCAAsC,KAAK,UAAU,eAKpK,K,0BAiBC,WAAqB,mCACpB,MACC,gBACA,8CACA,iCACA,cAGD,QAAU,OAAc,UAAI,EAE5B,UAAO,oBAAoB,GAAS,QAAQ,SAC3C,KAAK,GAAQ,EAGd,KACC,IADE,KAAK,kC,2FAgCG,EAAgB,EAAwE,6DAAnC,IAAE,GAAiC,6IAC7F,EAAgB,EAAgB,EAGvC,uBAJA,qCASO,iBACN,KAAkB,GAAE,KAAM,QAAS,KAAM,QAAS,OAClD,QAAkB,GAAE,KAAM,SAAU,KAAM,SAAU,OACpD,YAAK,WAAc,KAAK,eAAe,iBAAmB,EAE1D,OAEA,0GAEA,aAAO,iBAAiB,OACvB,aACA,oBAGD,mBAAK,eAAe,QAAQ,SAC3B,KAAc,UAAU,IAGzB,4BAAK,eAAe,aAAa,UAAU,IAG5C,+CAMC,eAKI,GALA,GAAiB,KAAK,eAE1B,gCAEA,KAAI,EAAS,KAAK,UAClB,OAAQ,EAAI,EAAG,EAAI,EAAQ,IAC1B,IAEA,EACqB,GADlB,KAAK,UAAU,GAAG,6BACpB,IAAqB,KAAK,iBAAmB,KAAK,UAAU,GAAG,eAAiB,EAE5D,KAAC,KAAK,iBAAmB,KAAK,UAAU,GAAG,cAGhE,IAAU,KACT,KAAK,UAAU,GAAG,YAAY,QAAQ,KAAK,UAAU,GAAG,mBAAoB,EAAgB,WAI9F,YAAK,OACL,QAAK,SACL,wCAGA,gBAAK,iBAAmB,KAAK,eAAe,aAC5C,6BAAK,iBAAmB,KAAK,iBAAiB,KAAK,WACnD,WAAK,eAAiB,KAAK,iBAAmB,OAAO,QAAU,KAAK,WAEpE,UACK,GADD,GAAS,KAAK,UAClB,OAAS,EAAI,EAAG,EAAI,EACnB,SAAK,UAAU,GAAG,aAAe,KAAK,IAAI,KAAK,eAAiB,KAAK,UAAU,GAAG,8BAAgC,KAEnH,gDAGA,gBAEA,6BAGK,GAHD,GAAkB,KAAK,UAC3B,OAAI,EAAuB,KAAK,eAEhC,OAAS,EAAI,EAAG,EAAI,EACnB,QAAK,GAAI,GAAI,EAAG,EAAI,EACnB,SAAK,eAAe,GAAG,MAAM,KAAK,WAAW,MAAQ,KAAK,UAAU,GAAG,aAAa,WAGtF,2C,SAGG,IAAC,MACH,+BACC,aAEA,YACC,WADE,EAAM,QAMX,yBAAK,SACL,uBAGA,6FACA,SACA,GAAI,EAAS,KAAK,eAElB,WAAI,EAAI,EAAG,EAAI,EACd,SAAK,eAAe,GAAG,MAAM,eAE9B,iB","file":"dist/parallaxative.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c29502c5f77f4f834127","/**\n * Track the relative position of an element as it scrolls by.\n */\nclass ScrollDetector {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {HTMLElement} scrollTarget\n\t *     Element whose position to track\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {bool} scrollIsVertical: Whether to track horizontal or vertical scrolling position.\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(scrollTarget, options) {\n\t\tvar defaultOptions = {\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\tthis.scrollTarget = scrollTarget;\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.updateResizeProperties();\n\n\t\twindow.addEventListener('resize', () => {\n\t\t\tthis.updateResizeProperties();\n\t\t});\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeProperties();\n\t\t});\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.rect = this.scrollTarget.getBoundingClientRect();\n\t\tthis.documentOffsets = {top: this.rect.top + this.constructor.getVerticalScroll(), left: this.rect.left + this.constructor.getHorizontalScroll() };\n\t\tthis.windowSizes = { width: window.innerWidth, height: window.innerHeight };\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos, zeroPoint, completePoint;\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscrollPos = this.constructor.getVerticalScroll();\n\t\t\toffset = this.documentOffsets.top;\n\t\t\tsize = this.rect.height;\n\t\t\twindowSize = this.windowSizes.height;\n\n\t\t} else {\n\t\t\tscrollPos = this.constructor.getHorizontalScroll();\n\t\t\toffset = this.documentOffsets.left;\n\t\t\tsize = this.rect.width;\n\t\t\twindowSize = this.windowSizes.width;\n\t\t}\n\n\t\tzeroPoint = offset - windowSize;\n\t\tcompletePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tstatic getVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tstatic getHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}\n\n/**\n * Run a function based on a ScrollDetector\n */\nclass ScrollTrigger {\n\tconstructor(scrollDetector, options = {}, triggerTarget = scrollDetector.scrollTarget) {\n\t\tvar defaultOptions = {\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\ttriggerPosition: 0.15,\n\t\t\ttriggerFunction: function(el) {\n\t\t\t\tel.classList.remove('offscreen');\n\t\t\t},\n\t\t\ttriggerOnDeactivate: true\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.triggerTarget = triggerTarget;\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\t}\n\n\tinit() {\n\t\tthis.listener = () => {\n\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\tthis.requestUpdate();\n\t\t\t}\n\t\t};\n\n\t\tthis.listener();\n\n\t\twindow.addEventListener('scroll', this.listener);\n\t\twindow.addEventListener('resize', this.listener);\n\t}\n\n\ttrigger() {\n\t\tthis.triggerFunction(this.triggerTarget);\n\t}\n\n\ttest() {\n\t\tif(this.scrollDetector.relativeScrollPosition() > this.triggerPosition) {\n\t\t\tthis.triggerOnDeactivate = true;\n\t\t\tthis.deactivate();\n\t\t}\n\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.test(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\twindow.removeEventListener('scroll', this.listener);\n\t\t\twindow.removeEventListener('resize', this.listener);\n\n\t\t\tif(this.triggerOnDeactivate) {\n\t\t\t\tthis.trigger();\n\t\t\t}\n\t\t}\n\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n\n/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nclass ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\tgetCSSValue(scrollPosition) {\n\t\treturn this.valueFormat.replace(this.substitutionString, ((this.endValue - this.startValue) * scrollPosition + this.startValue).toString() + this.unit);\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nclass ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSetSeparator: ' ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\tstartPosition: 0, // FIXME: Not implemented\n\t\t\tendPosition: 1 // FIXME: Not implemented\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.valueSets = valueSets;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(() => {\n\t\t\tthis.respond();\n\t\t});\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tthis.ticking = false;\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tcssValues.push( this.valueSets[i].getCSSValue(scrollPosition) );\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t\twindow.removeEventListener('resize', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n\n\tstatic isIE() {\n\t\treturn (\n\t\t\t(navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))\n\t\t);\n\t}\n}\n\n/**\n * Default option container for ParallaxAnimation CSS values.\n */\nclass ParallaxAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel === 0) {\n\t\t\tthrow 'scrollPixelsPerParallaxPixel must not be zero.';\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxAnimationValueSet ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tvar xDimensions = { size: 'width', Size: 'Width', offset: 'left' };\n\t\tvar yDimensions = { size: 'height', Size: 'Height', offset: 'top' };\n\t\tthis.dimensions =  this.scrollDetector.scrollIsVertical ? yDimensions : xDimensions;\n\n\t\tthis.updateResizeProperties();\n\n\t\tsuper.init();\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeCSS();\n\t\t\tthis.updateCSS();\n\t\t});\n\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('parallax-animated');\n\t\t});\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallax-container');\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar cssValues = [];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tvar scrollTranslate;\n\n\t\t\tif(this.valueSets[i].scrollPixelsPerParallaxPixel < 0) {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * (1 - scrollPosition));\n\t\t\t} else {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * scrollPosition);\n\t\t\t}\n\n\t\t\tcssValues.push(\n\t\t\t\tthis.valueSets[i].valueFormat.replace(this.valueSets[i].substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tthis.scrollTargetSize = this.scrollTargetRect[this.dimensions.size];\n\t\tthis.scrollDistance = this.scrollTargetSize + window['inner' + this.dimensions.Size];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.valueSets[i].parallaxSize = Math.abs(this.scrollDistance / this.valueSets[i].scrollPixelsPerParallaxPixel) + this.scrollTargetSize;\n\t\t}\n\t}\n\n\tupdateResizeCSS() {\n\t\tthis.updateResizeProperties();\n\n\t\tvar valueSetsLength = this.valueSets.length;\n\t\tvar animateTargetsLength = this.animateTargets.length;\n\n\t\tfor (var i = 0; i < valueSetsLength; i++) {\n\t\t\tfor (var j = 0; j < animateTargetsLength; j++) {\n\t\t\t\tthis.animateTargets[j].style[this.dimensions.size] = this.valueSets[i].parallaxSize.toString() + 'px';\n\t\t\t}\n\t\t}\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\treset() {\n\t\tsuper.reset();\n\t\tvar i;\n\t\tvar length = this.animateTargets.length;\n\n\t\tfor(i = 0; i < length; i++) {\n\t\t\tthis.animateTargets[i].style.removeProperty('height');\n\t\t}\n\t}\n}\n\nexport { ScrollDetector, ScrollTrigger, ScrollAnimation, ScrollAnimationValueSet, ParallaxAnimation, ParallaxAnimationValueSet };\n\n\n// WEBPACK FOOTER //\n// ./src/parallaxative.js?es5"],"sourceRoot":""}