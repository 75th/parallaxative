{"version":3,"sources":["../src/parallaxative.js"],"names":["validateOptions","options","properties","_typeof","valueSets","ScrollAnimationValueSet","ParallaxAnimationValueSet","normalizeMediaQueryList","mql","MediaQueryList","window","matchMedia","ParallaxativeException","normalizeDOMElement","el","HTMLElement","document","querySelector","normalizeScrollDetector","scrollDetector","defaultScrollTarget","ScrollDetector","scrollTarget","scrollIsVertical","throwingFunction","log","type","arguments","length","undefined","data","level","_classCallCheck","this","console","ScrollTrigger","ParallaxAnimation","animateTarget","_this","defaultOptions","Object","getOwnPropertyNames","forEach","name","updateResizeProperties","addEventListener","rect","getBoundingClientRect","documentOffsets","top","constructor","getVerticalScroll","left","getHorizontalScroll","windowSizes","width","innerWidth","height","innerHeight","assign","offset","size","windowSize","scrollPos","zeroPoint","relativeScrollPosition","Math","min","max","scrollY","pageYOffset","documentElement","scrollTop","body","scrollX","pageXOffset","scrollLeft","_this2","activateImmediately","activeMediaQueryList","triggerFunction","classList","remove","triggerPosition","triggerTarget","triggerOnDeactivate","addListener","respond","scrollDetectorIsEmpty","triggerTargetIsEmpty","_this3","listener","requestUpdate","deactivate","ticking","_this4","requestAnimationFrame","test","activated","init","removeEventListener","trigger","matches","activate","_this5","unit","valueFormat","substitutionString","startValue","endValue","resetValue","scrollPosition","replace","toString","ScrollAnimation","animateTargets","_this6","defaultValueSets","valueSetSeparator","removePropertiesOnReset","startPosition","endPosition","Array","from","querySelectorAll","parentNode","err","listeners","_this7","add","updateCSS","push","e","cssValues","i","j","animateProperty","style","join","clampedRelativeScrollPosition","getCSSValue","setCSS","_this8","_this9","property","removeProperty","valueSet","reset","navigator","appName","RegExp","exec","userAgent","_this10","scrollPixelsPerParallaxPixel","_possibleConstructorReturn","_getPrototypeOf","call","target","_this11","dimensions","Size","_get","prototype","updateResizeCSS","index","filter","scrollTranslate","scrollTargetSize","parallaxSize","scrollTargetRect","scrollDistance","abs","valueSetsLength","animateTargetsLength","event","_this12"],"mappings":"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","sourcesContent":["function validateOptions(options) {\n\tif(typeof options.properties === 'string') {\n\t\toptions.properties = [ options.properties ];\n\t}\n\n\tif(\n\t\ttypeof options.valueSets === 'object' && (\n\t\t\toptions.valueSets instanceof ScrollAnimationValueSet ||\n\t\t\toptions.valueSets instanceof ParallaxAnimationValueSet\n\t\t)\n\t) {\n\t\toptions.valueSets = [ options.valueSets ];\n\t}\n\n\treturn options;\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction arrayify(obj) {\n\treturn (obj instanceof Array || obj instanceof NodeList) ? obj : [ obj ];\n}\n\nfunction normalizeMediaQueryList(mql) {\n\tif(mql instanceof MediaQueryList || mql === null) {\n\t\treturn mql;\n\t}\n\n\tif(typeof mql === 'string' && mql) {\n\t\treturn window.matchMedia(mql);\n\t}\n\n\tthrow new ParallaxativeException(validateOptions, 'badActiveMediaQueryList');\n}\n\nfunction normalizeDOMElement(el) {\n\tif (el instanceof HTMLElement) {\n\t\treturn el;\n\t}\n\n\tif (typeof el === 'string') {\n\t\tel = document.querySelector(el);\n\n\t\tif(!el) {\n\t\t\tthrow new ParallaxativeException(normalizeDOMElement, 'emptySelectorQuery');\n\t\t}\n\n\t\treturn el;\n\t}\n\n\tthrow new ParallaxativeException(normalizeDOMElement, 'badDOMElement');\n}\n\nfunction normalizeScrollDetector(scrollDetector, defaultScrollTarget) {\n\n\tif(!(scrollDetector instanceof ScrollDetector)) {\n\t\tif(typeof scrollDetector === 'undefined' || !scrollDetector) { // Allow passing nothing\n\t\t\tscrollDetector = new ScrollDetector(defaultScrollTarget);\n\t\t} else if (typeof scrollDetector === 'string' || scrollDetector instanceof HTMLElement) {\n\t\t\tlet scrollTarget = normalizeDOMElement(scrollDetector);\n\t\t\tscrollDetector = new ScrollDetector(scrollTarget);\n\t\t} else if(typeof scrollDetector === 'object') { // Allow passing ScrollDetector's OR ScrollAnimation's options\n\t\t\tif(optionsAreForScrollDetector(scrollDetector)) {\n\t\t\t\tscrollDetector = new ScrollDetector(defaultScrollTarget, scrollDetector);\n\t\t\t} else {\n\t\t\t\tthrow new ParallaxativeException(null, 'optionsNotForScrollDetector', {}, 'none');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scrollDetector;\n}\n\nfunction optionsAreForScrollDetector(options) {\n\treturn typeof options.scrollIsVertical !== 'undefined' || typeof options.scrollTarget !== 'undefined';\n}\n\nclass ParallaxativeException {\n\tconstructor(throwingFunction, type = 'generic', data = {}, level = 'error') {\n\t\tthis.throwingFunction = throwingFunction;\n\t\tthis.type = type;\n\t\tthis.data = data;\n\n\t\tvar log;\n\n\t\tif(level === 'none') {\n\t\t\tlog = () => {};\n\t\t} else {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tlog = console[level];\n\t\t}\n\n\t\tswitch (true) {\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'badScrollTarget'):\n\t\t\t\tlog('scrollTarget must be a query selector string or an HTMLElement node.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'scrollTargetQueryNull'):\n\t\t\t\tlog('scrollTarget query selector string did not match any elements.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollDetector && type === 'scrollTargetEmpty'):\n\t\t\t\tlog('scrollTarget was not provided, was empty, or did not resolve to a DOM element.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ScrollTrigger && type === 'noTriggerElement'):\n\t\t\t\tlog('You must provide ScrollTarget either a scrollDetector or a triggerTarget.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'badActiveMediaQueryList'):\n\t\t\t\tlog('activeMediaQueryList, if provided at all, must be either a media query string or a MediaQueryList instance.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'duplicateOptions'):\n\t\t\t\tlog('ScrollAnimation’s second parameter looked like it was options for ScrollAnimation, but other options were provided in the third parameter. If the third parameter is present, the second parameter must pertain to a ScrollDetector.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ParallaxAnimationValueSet && type === 'divideByZero'):\n\t\t\t\tlog('scrollPixelsPerParallaxPixel must not be zero.');\n\t\t\t\tbreak;\n\t\t\tcase (throwingFunction === ParallaxAnimation && type === 'overlyNestedAnimateTarget'):\n\t\t\t\tlog('Parallax animateTarget %o is nested too many levels beneath scrollTarget %o. The animateTarget must be a direct child of the scrollTarget.', data.animateTarget, data.scrollTarget);\n\t\t\t\tbreak;\n\t\t\tcase (type === 'badDOMElement'):\n\t\t\t\tlog('A Parallaxative class couldn’t convert your input into an HTMLElement');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'emptySelectorQuery'):\n\t\t\t\tlog('Your query selector didn’t match any DOM elements.');\n\t\t\t\tbreak;\n\t\t\tcase (type === 'optionsNotForScrollDetector'):\n\t\t\t\tlog('Options in a scrollDetector parameter were not for a scrollDetector and were not detected to be for something else.');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog('Error in Parallaxative class %o of type %o with data %o.', throwingFunction, type, data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Track the relative position of an element as it scrolls by.\n */\nclass ScrollDetector {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {HTMLElement} scrollTarget\n\t *     Element whose position to track\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {bool} scrollIsVertical: Whether to track horizontal or vertical scrolling position.\n\t *\n\t * @todo Track vertical and horizontal position at the same time, and let animations use both simultaneously\n\t */\n\tconstructor(options) {\n\t\tthis.defaultOptions = {\n\t\t\tscrollTarget: null,\n\t\t\tscrollIsVertical: true\n\t\t};\n\n\t\toptions = this.validateOptions(options);\n\n\t\tObject.getOwnPropertyNames(this.defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.updateResizeProperties();\n\t\twindow.addEventListener('resize', this.updateResizeProperties);\n\t\twindow.addEventListener('load', this.updateResizeProperties);\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.rect = this.scrollTarget.getBoundingClientRect();\n\t\tthis.documentOffsets = {top: this.rect.top + this.constructor.getVerticalScroll(), left: this.rect.left + this.constructor.getHorizontalScroll() };\n\t\tthis.windowSizes = { width: window.innerWidth, height: window.innerHeight };\n\t}\n\n\tvalidateOptions(options) {\n\t\tif(options instanceof HTMLElement || typeof options === 'string') { // Allow providing bare DOM node\n\t\t\toptions = { scrollTarget: options };\n\t\t}\n\n\t\tif(typeof options.scrollTarget === 'string') {\n\t\t\toptions.scrollTarget = normalizeDOMElement(options.scrollTarget);\n\t\t}\n\n\t\tif(!(options.scrollTarget instanceof HTMLElement)) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'badScrollTarget');\n\t\t}\n\n\t\treturn Object.assign({}, this.defaultOptions, options);\n\t}\n\n\t/**\n\t * The relative position of the element, where 0 is the pixel\n\t * before it scrolls onto the screen, and 1 is the pixel after\n\t * it scrolls off the screen. All other values are interpolated\n\t * linearly.\n\t *\n\t * @return {float}\n\t */\n\trelativeScrollPosition() {\n\t\tvar offset, size, windowSize, scrollPos, zeroPoint, completePoint;\n\n\t\tif(this.scrollIsVertical) {\n\t\t\tscrollPos = this.constructor.getVerticalScroll();\n\t\t\toffset = this.documentOffsets.top;\n\t\t\tsize = this.rect.height;\n\t\t\twindowSize = this.windowSizes.height;\n\n\t\t} else {\n\t\t\tscrollPos = this.constructor.getHorizontalScroll();\n\t\t\toffset = this.documentOffsets.left;\n\t\t\tsize = this.rect.width;\n\t\t\twindowSize = this.windowSizes.width;\n\t\t}\n\n\t\tzeroPoint = offset - windowSize;\n\t\tcompletePoint = offset + size;\n\t\treturn (scrollPos - zeroPoint) / (completePoint - zeroPoint);\n\t}\n\n\n\t/**\n\t * Same as relativeScrollPosition, except all negative values are returned as zero\n\t * and all values greater than 1 are returned as 1.\n\t *\n\t * @param {float} relativeScrollPosition\n\t *     The relativeScrollPosition can be provided as a parameter to save on calculating\n\t *     it multiple times in the same function.\n\t *\n\t * @return {[type]}\n\t */\n\tclampedRelativeScrollPosition(relativeScrollPosition = this.relativeScrollPosition()) {\n\t\treturn Math.min(Math.max(relativeScrollPosition, 0), 1);\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollY\n\t *\n\t * @return {number}\n\t */\n\tstatic getVerticalScroll() {\n\t\tif('scrollY' in window) {\n\t\t\treturn window.scrollY;\n\t\t} else if ('pageYOffset' in window) {\n\t\t\treturn window.pageYOffset;\n\t\t} else if (document.documentElement.scrollTop > 0) {\n\t\t\treturn document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn document.body.scrollTop;\n\t\t}\n\t}\n\n\t/**\n\t * Fallbacks upon fallbacks for window.scrollX\n\t *\n\t * @return {number}\n\t */\n\tstatic getHorizontalScroll() {\n\t\tif('scrollX' in window) {\n\t\t\treturn window.scrollX;\n\t\t} else if ('pageXOffset' in window) {\n\t\t\treturn window.pageXOffset;\n\t\t} else if (document.documentElement.scrollLeft > 0) {\n\t\t\treturn document.documentElement.scrollLeft;\n\t\t} else {\n\t\t\treturn document.body.scrollLeft;\n\t\t}\n\t}\n}\n\n/**\n * Run a function based on a ScrollDetector\n */\nclass ScrollTrigger {\n\tconstructor(options = {}) {\n\t\toptions = this.validateOptions(options);\n\n\t\tthis.defaultOptions = {\n\t\t\tactivateImmediately: true,\n\t\t\tactiveMediaQueryList: '(min-width: 720px)',\n\t\t\tscrollDetector: null, // Handled above\n\t\t\ttriggerFunction: function(el) {\n\t\t\t\tel.classList.remove('offscreen');\n\t\t\t},\n\t\t\ttriggerPosition: 0.15,\n\t\t\ttriggerTarget: null, // Handled above\n\t\t\ttriggerOnDeactivate: true\n\t\t};\n\n\t\tObject.getOwnPropertyNames(this.defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.activeMediaQueryList.addListener(this.respond);\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\t}\n\n\tvalidateOptions(options) {\n\t\tvar scrollDetectorIsEmpty = typeof options.scrollDetector === 'undefined' || !!options.scrollDetector;\n\t\tvar triggerTargetIsEmpty = typeof options.triggerTarget === 'undefined' || !!options.triggerTarget;\n\n\t\tif(scrollDetectorIsEmpty && triggerTargetIsEmpty) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'noTriggerElement');\n\t\t}\n\n\t\tif(scrollDetectorIsEmpty) {\n\t\t\toptions.triggerTarget = normalizeDOMElement(options.triggerTarget);\n\t\t\toptions.scrollDetector = new ScrollDetector(options.triggerTarget);\n\t\t} else if (triggerTargetIsEmpty) {\n\t\t\toptions.scrollDetector = normalizeScrollDetector(options.scrollDetector, null);\n\t\t\toptions.triggerTarget = options.scrollDetector.scrollTarget;\n\t\t}\n\n\t\toptions = Object.assign({}, this.defaultOptions, options);\n\n\t\toptions.activeMediaQueryList = normalizeMediaQueryList(options.activeMediaQueryList);\n\n\t\treturn options;\n\t}\n\n\tinit() {\n\t\tthis.listener = () => {\n\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\tthis.requestUpdate();\n\t\t\t}\n\t\t};\n\n\t\tthis.listener();\n\n\t\twindow.addEventListener('scroll', this.listener);\n\t\twindow.addEventListener('resize', this.listener);\n\t}\n\n\ttrigger() {\n\t\tthis.triggerFunction(this.triggerTarget);\n\t}\n\n\ttest() {\n\t\tif(this.scrollDetector.relativeScrollPosition() > this.triggerPosition) {\n\t\t\tthis.triggerOnDeactivate = true;\n\t\t\tthis.deactivate();\n\t\t}\n\n\t\tthis.ticking = false;\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.test(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\twindow.removeEventListener('scroll', this.listener);\n\t\t\twindow.removeEventListener('resize', this.listener);\n\n\t\t\tif(this.triggerOnDeactivate) {\n\t\t\t\tthis.trigger();\n\t\t\t}\n\t\t}\n\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n}\n\n\n/**\n * Default option container for ScrollAnimation CSS values.\n * Making this a class might be overkill?\n */\nclass ScrollAnimationValueSet {\n\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} unit: CSS unit\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} startValue: The value applied to the element the moment it is scrolled onto the screen\n\t *         {number} endValue: The value applied to the element the moment it is scrolled off the screen\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tunit: 'vh',\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tstartValue: 20,\n\t\t\tendValue: -20,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(options).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\t}\n\n\tgetCSSValue(scrollPosition) {\n\t\treturn this.valueFormat.replace(this.substitutionString, ((this.endValue - this.startValue) * scrollPosition + this.startValue).toString() + this.unit);\n\t}\n}\n\n/**\n * Class to create and manage animations that are based on scrolling the window.\n */\nclass ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector. May also be a single bare HTMLElement\n\t *         or a query selector string\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {array<ScrollAnimationValueSet>} valueSets: Configuration for one or more values to be modified within a single CSS rule\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t */\n\tconstructor(animateTargets, scrollDetector, options, defaultValueSets = [ new ScrollAnimationValueSet() ]) {\n\t\tvar defaultOptions = {\n\t\t\tproperties: ['transform', 'msTransform'],\n\t\t\tvalueSets: defaultValueSets,\n\t\t\tvalueSetSeparator: ' ',\n\t\t\tremovePropertiesOnReset: true,\n\t\t\tactiveMediaQueryList: window.matchMedia('(min-width: 720px)'),\n\t\t\tactivateImmediately: true,\n\t\t\tstartPosition: 0, // FIXME: Not implemented\n\t\t\tendPosition: 1 // FIXME: Not implemented\n\t\t};\n\n\t\t// Syntax sugar for animateTargets\n\t\tif(animateTargets instanceof HTMLElement) { // Allow passing bare DOM node\n\t\t\tanimateTargets = [animateTargets];\n\t\t} else if(typeof animateTargets === 'string') { // Allow passing query selector string\n\t\t\tanimateTargets = Array.from(document.querySelectorAll(animateTargets));\n\t\t}\n\n\t\ttry {\n\t\t\tscrollDetector = normalizeScrollDetector(scrollDetector, animateTargets[0].parentNode, options);\n\t\t} catch(err) {\n\t\t\tif(err.type === 'optionsNotForScrollDetector') {\n\t\t\t\tif(typeof options === 'undefined') {\n\t\t\t\t\toptions = scrollDetector;\n\t\t\t\t\tscrollDetector = new ScrollDetector(animateTargets[0].parentNode);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ParallaxativeException(this.constructor, 'duplicateOptions');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(typeof options !== 'undefined') {\n\t\t\toptions = validateOptions(options, this.constructor);\n\t\t}\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tthis.animateTargets = animateTargets;\n\t\tthis.scrollDetector = scrollDetector;\n\t\tthis.listeners = [];\n\t\tthis.ticking = false;\n\t\tthis.activated = false;\n\n\t\tif(this.activateImmediately) {\n\t\t\tthis.respond();\n\t\t}\n\n\t\tthis.activeMediaQueryList.addListener(this.respond);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\tanimateTarget.classList.add('scroll-animated');\n\t\t\tthis.updateCSS();\n\n\t\t\tthis.listeners.push((e) => {\n\t\t\t\tvar relativeScrollPosition = this.scrollDetector.relativeScrollPosition();\n\t\t\t\tif(relativeScrollPosition > -0.1 && relativeScrollPosition < 1.1) {\n\t\t\t\t\tthis.requestUpdate(e);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('scroll', this.listeners[this.listeners.length - 1]);\n\t\t\twindow.addEventListener('resize', this.listeners[this.listeners.length - 1]);\n\t\t});\n\t}\n\n\t/**\n\t * Actually modify the CSS of the animateTarget.\n\t *\n\t * @param {array<string>} cssValues - CSS strings to be joined by the valueSetSeparator\n\t */\n\tsetCSS(cssValues) {\n\t\tfor(var i = 0; i < this.animateTargets.length; i++) {\n\t\t\tvar animateTarget = this.animateTargets[i];\n\n\t\t\tfor(var j = 0; j < this.properties.length; j++) {\n\t\t\t\tvar animateProperty = this.properties[j];\n\t\t\t\tanimateTarget.style[animateProperty] = cssValues.join(this.valueSetSeparator);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tupdateCSS() {\n\t\tthis.ticking = false;\n\t\tvar cssValues = [];\n\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tcssValues.push( this.valueSets[i].getCSSValue(scrollPosition) );\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t}\n\n\t/**\n\t * Throttle CSS updates to requestAnimationFrame.\n\t *\n\t * @return {void}\n\t */\n\trequestUpdate() {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => { this.updateCSS(); });\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\t/**\n\t * Set animateTarget CSS to prepare for deactivation of the animation.\n\t *\n\t * @return {void}\n\t */\n\treset() {\n\t\tif(this.removePropertiesOnReset) {\n\t\t\tthis.animateTargets.forEach(animateTarget => {\n\t\t\t\tthis.properties.forEach(property => {\n\t\t\t\t\tanimateTarget.style.removeProperty(property);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tvar cssValues = [];\n\n\t\t\tthis.valueSets.forEach(valueSet => {\n\t\t\t\tcssValues.push(\n\t\t\t\t\tvalueSet.valueFormat.replace(valueSet.substitutionString, valueSet.resetValue.toString() + valueSet.unit)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.setCSS(cssValues);\n\t\t}\n\n\t\tvar i;\n\t\tvar length = this.animateTargets.length;\n\n\t\tfor(i = 0; i < length; i++) {\n\t\t\tthis.animateTargets[i].classList.remove('scroll-animated');\n\t\t}\n\t}\n\n\t/**\n\t * Call this.init() if it's not activated already\n\t *\n\t * @return {void}\n\t */\n\tactivate() {\n\t\tif(!this.activated) {\n\t\t\tthis.init();\n\t\t\tthis.activated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Disable the animation and restore default values.\n\t *\n\t * @return {void}\n\t */\n\tdeactivate() {\n\t\tif(this.activated) {\n\t\t\tthis.listeners.forEach(listener => {\n\t\t\t\twindow.removeEventListener('scroll', listener);\n\t\t\t\twindow.removeEventListener('resize', listener);\n\t\t\t});\n\t\t}\n\n\t\tthis.reset();\n\t\tthis.activated = false;\n\t}\n\n\t/**\n\t * Call activate() or deactivate() as needed, depending on the activeMediaQueryList.\n\t *\n\t * @return {[type]}\n\t */\n\trespond() {\n\t\tif(this.activeMediaQueryList.matches) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\t}\n\n\tstatic isIE() {\n\t\treturn (\n\t\t\t(navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))\n\t\t);\n\t}\n}\n\n/**\n * Default option container for ParallaxAnimation CSS values.\n */\nclass ParallaxAnimationValueSet {\n\t/**\n\t * Constructor. All it does is merge supplied options with defaults.\n\t *\n\t * @param {obj} options\n\t *     Parameters for constructing CSS values to be put in a single CSS rule.\n\t *         {str} valueFormat: String surrounding the CSS value, using a substitution string of your choice\n\t *         {str} substitutionString: As above\n\t *         {number} scrollPixelsPerParallaxPixel: How slowly the parallax effect should move.\n\t *             Higher numbers make it go more slowly. 0 would cause a divide-by-zero error and\n\t *             throws an exception.\n\t *         {number} resetValue: The value applied to the element when the animation is disabled\n\t *\n\t */\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvalueFormat: 'translate3d(0px, _, 0px)',\n\t\t\tsubstitutionString: '_',\n\t\t\tscrollPixelsPerParallaxPixel: 10,\n\t\t\tresetValue: 0\n\t\t};\n\n\t\toptions = Object.assign({}, defaultOptions, options);\n\n\t\tObject.getOwnPropertyNames(defaultOptions).forEach(name => {\n\t\t\tthis[name] = options[name];\n\t\t});\n\n\t\tif(this.scrollPixelsPerParallaxPixel === 0) {\n\t\t\tthrow new ParallaxativeException(this.constructor, 'divideByZero');\n\t\t}\n\t}\n}\n\n/**\n * Class to create and manage animations of parallax background elements.\n */\nclass ParallaxAnimation extends ScrollAnimation {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {array<HTMLElement>} animateTargets\n\t *     The elements to animate based on the scroll position of the ScrollDetector\n\t *\n\t * @param {ScrollDetector} scrollDetector\n\t *\n\t * @param {object} options\n\t *     Other options that may be omitted to use default values\n\t *         {array<string>} properties: The JavaScript CSS property names to modify\n\t *         {string} valueSetSeparator: String on which to join the different CSS values for this rule\n\t *         {bool} removePropertiesOnReset: Whether to unset the CSS properties altogether on deactivation,\n\t *             instead of setting them to the resetValue\n\t *         {MediaQueryList} activeMediaQueryList: The MediaQueryList controlling activation and deactivation of this object\n\t *         {bool} activateImmediately: Whether to turn on the animation immediately upon construction.\n\t *             (Even if true, the animation will not activate if activeMediaQueryList.matches is false.)\n\t *\n\t * @param {array<ScrollAnimationValueSet>} valueSets\n\t *     Configuration for one or more values to be used in the single CSS rule\n\t *     this object manages.\n\t */\n\tconstructor(animateTargets, scrollDetector, options, valueSets = [ new ParallaxAnimationValueSet() ]) {\n\t\tsuper(animateTargets, scrollDetector, options, valueSets);\n\t}\n\n\t/**\n\t * Set up and turn on the animation.\n\t *\n\t * @return {void}\n\t */\n\tinit() {\n\t\tthis.dimensions =\n\t\t\tthis.scrollDetector.scrollIsVertical ?\n\t\t\t{ size: 'height', Size: 'Height', offset: 'top' } :\n\t\t\t{ size: 'width', Size: 'Width', offset: 'left' }\n\t\t;\n\n\t\tthis.updateResizeProperties();\n\n\t\tsuper.init();\n\n\t\tthis.scrollDetector.scrollTarget.classList.add('parallax-container');\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tthis.updateResizeCSS();\n\t\t\tthis.updateCSS();\n\t\t});\n\n\t\tvar i;\n\t\tvar target;\n\t\tvar length = this.animateTargets.length;\n\n\t\ttry {\n\t\t\tfor(i = 0; i < length; i++) {\n\t\t\t\ttarget = this.animateTargets[i];\n\n\t\t\t\ttarget.classList.add('parallax-animated');\n\n\t\t\t\tif(target.parentNode !== this.scrollDetector.scrollTarget) {\n\t\t\t\t\tthrow new ParallaxativeException(this.constructor, 'overlyNestedAnimateTarget', {index: i, animateTarget: target, scrollTarget: this.scrollDetector.scrollTarget });\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(err) {\n\t\t\tthis.deactivate();\n\n\t\t\tthis.animateTargets = this.animateTargets.filter((target) => {\n\t\t\t\ttarget !== err.animateTarget;\n\t\t\t});\n\n\t\t\tif(this.animateTargets.length) {\n\t\t\t\tthis.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recalculate CSS values based on the scroll position.\n\t *\n\t * @return {void}\n\t */\n\tupdateCSS() {\n\t\tvar scrollPosition = this.scrollDetector.clampedRelativeScrollPosition();\n\n\t\tvar cssValues = [];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor(var i = 0; i < length; i++) {\n\t\t\tvar scrollTranslate;\n\n\t\t\tif(this.valueSets[i].scrollPixelsPerParallaxPixel < 0) {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * (1 - scrollPosition));\n\t\t\t} else {\n\t\t\t\tscrollTranslate = -((this.scrollTargetSize - this.valueSets[i].parallaxSize) * scrollPosition);\n\t\t\t}\n\n\t\t\tcssValues.push(\n\t\t\t\tthis.valueSets[i].valueFormat.replace(this.valueSets[i].substitutionString, scrollTranslate.toString() + 'px')\n\t\t\t);\n\t\t}\n\n\t\tthis.setCSS(cssValues);\n\t\tthis.ticking = false;\n\t}\n\n\tupdateResizeProperties() {\n\t\tthis.scrollTargetRect = this.scrollDetector.scrollTarget.getBoundingClientRect();\n\t\tthis.scrollTargetSize = this.scrollTargetRect[this.dimensions.size];\n\t\tthis.scrollDistance = this.scrollTargetSize + window['inner' + this.dimensions.Size];\n\n\t\tvar length = this.valueSets.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.valueSets[i].parallaxSize = Math.abs(this.scrollDistance / this.valueSets[i].scrollPixelsPerParallaxPixel) + this.scrollTargetSize;\n\t\t}\n\t}\n\n\tupdateResizeCSS() {\n\t\tthis.updateResizeProperties();\n\n\t\tvar valueSetsLength = this.valueSets.length;\n\t\tvar animateTargetsLength = this.animateTargets.length;\n\n\t\tfor (var i = 0; i < valueSetsLength; i++) {\n\t\t\tfor (var j = 0; j < animateTargetsLength; j++) {\n\t\t\t\tthis.animateTargets[j].style[this.dimensions.size] = this.valueSets[i].parallaxSize.toString() + 'px';\n\t\t\t}\n\t\t}\n\t}\n\n\trequestUpdate(event) {\n\t\tif(!this.ticking) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.updateCSS();\n\n\t\t\t\tif(event.type === 'resize') {\n\t\t\t\t\tthis.updateResizeCSS();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.ticking = true;\n\t}\n\n\treset() {\n\t\tvar i;\n\t\tvar length = this.animateTargets.length;\n\n\t\tfor(i = 0; i < length; i++) {\n\t\t\tthis.animateTargets[i].style.removeProperty('height');\n\t\t\tthis.animateTargets[i].classList.remove('parallax-animated');\n\t\t\tthis.animateTargets[i].parentNode.classList.remove('parallax-anchor');\n\t\t}\n\n\t\tsuper.reset();\n\n\t\tthis.scrollDetector.scrollTarget.classList.remove('parallax-container');\n\t}\n}\n\nexport { ScrollDetector, ScrollTrigger, ScrollAnimation, ScrollAnimationValueSet, ParallaxAnimation, ParallaxAnimationValueSet };"]}